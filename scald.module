<?php

/**
 * @defgroup scald Scald is Content, Attribution, Licensing, & Distribution
 *
 */

/**
 * @file
 * The Scald Core, which handles all Scald Registries and dispatch.
 *
 * The Scald Core handles the Scald Registries for all the aspects of Scald.
 * The Scald API is also defined here; the majority of a developer's
 * interaction with Scald will be through the Scald API defined herein.  See
 * the docs folder for more detailed information.
 *
 * @ingroup scald
 */

require_once('scald.constants.inc');




/*******************************************************************************
 * SCALD PROVIDERS & CONFIGURATION
 ******************************************************************************/

/**
 * Get the available Scald Unified Types
 *
 * This function determines and returns a structured array specifying all the
 *  currently provided Scald Unified Types.  The Scald Unified Types array has
 *  the following format:
 *  array(
 *    'type-slug' => array(
 *      'title'     => 'Plain-text title',
 *      'providers' => array(
 *        'provider',
 *        ...
 *    ),
 *    ...
 *  );
 *
 * @return
 *   The Scald Unified Types array
 */
function scald_types() {
  $types = db_select('scald_types', 's')
    ->fields('s', array('type', 'title', 'provider'))
    ->execute()
    ->fetchAllAssoc('type');

  return $types;


  // Ensure only a single entry is recorded for each type/provider mapping to
  //  avoid unnecessary executions of hooks.
  $providers_results = db_query('SELECT DISTINCT type, provider FROM {scald_atom_providers}');
  while ($provider_raw = db_fetch_array($providers_results)) {
    $scald_types[$provider_raw['type']]['atom_providers'][] = $provider_raw['provider'];
  }

  return $scald_types;
} // end _scald_types()



/**
 * Get available Scald Contexts
 *
 * This function determines and returns a structured array specifying all the
 *  currently provided Scald Contexts.  The Scald Contexts array is cached in
 *  the Drupal variables table and only rebuilt upon request from this function.
 *  The Scald Contexts array has the following format:
 *  array(
 *    'context-slug' => array(
 *      'provider'        => 'provider-name',
 *      'render_language' => 'language-slug',   // e.g. 'XHTML'
 *      'type_format'         => array(
 *        'type-slug'   => array(
 *          'file_format' => 'format-slug'
 *          'transcoder'  => 'transcoder-slug'
 *        ),
 *        ...
 *      ),
 *    ),
 *    ...
 *  );
 *
 * @return
 *   The Scald Contexts array
 */
function scald_contexts($reset = FALSE) {
  return _scald_get_info('contexts', $reset);
}

/**
 * Implements hook_scald_contexts_alter.
 *
 * Adds informations on the configured transcoder formats to
 * the standard info hook output.
 */
function scald_scald_contexts_alter(&$contexts) {
  $result = db_select('scald_context_type_transcoder', 's')
    ->fields('s')
    ->execute();

  while ($row = $result->fetchAssoc()) {
    $contexts[$row['context']]['type_format'][$row['type']] = $row;
  }
}


/**
 * Get the available Scald Actions
 *
 * This function returns a structured array which specifies all the currently
 *  provided Scald Actions.  The actions are in an array with one or more
 *  elements in the format:
 *  array(
 *    'action-slug' => array(
 *      'provider' => 'provider-name',
 *      'title'    => 'Plain-text title',
 *      'mask'     => 0x04,
 *    ),
 *    ..
 *  );
 *
 * @return
 *  The Scald Actions array.
 */
function scald_actions($reset = FALSE) {
  return _scald_get_info('actions', $reset);
}

/**
 * Implements hook_scald_actions_alter.
 *
 * Assigns each actions an unique bitmask.
 */
function scald_scald_actions_alter(&$actions) {
  $powers = variable_get('scald_actions_powers', array('@admin' => 0));
  $max_power = empty($powers) ? 0 : max($powers);
  $new_power = FALSE;
  foreach ($actions as $name => $action) {
    if (!isset($powers[$name])) {
      $new_power = TRUE;
      $powers[$name] = ++$max_power;
    }

    $actions[$name]['bitmask'] = pow(2, $powers[$name]);
  }

  if ($new_power) {
    variable_set('scald_actions_powers', $powers);
  }
}

/**
 * Get the available Scald Transcoders
 *
 * This function returns a structured array which specifies all the currently
 *  provided Scald Transcoders.  The actions are in an array with one or more
 *  elements in the format:
 *  array(
 *    'transcoder-slug' => array(
 *      'provider' => 'provider-name',
 *      'formats'  => array(
 *        'type-slug' => 'file_format',
 *        ...
 *    ),
 *    ...
 *  );
 *
 * @return
 *   The Scald Transcoders array
 */
function scald_transcoders($reset = FALSE) {
  return _scald_get_info('transcoders', $reset);
}

/**
 * Get the list of module that have registered themselves as atom providers.
 *
 * This function returns an associative array with the following formats:
 * array(
 *   'type-slug1' => array(
 *     'module-name1' => 'label1',
 *     'module-name2' => 'label2',
 *   )
 * );
 *
 * @return
 *   The Scald Atom Providers array.
 */
function scald_atom_providers($reset = FALSE) {
  $types = array();
  $hook = 'scald_atom_providers';
  foreach (module_implements($hook) as $module) {
    foreach (module_invoke($module, $hook) as $type => $label) {
      $types[$type][$module] = $label;
    }
  }
  drupal_alter($hook, $types);
  return $types;
}

/**
 * Get the info from all modules on a specific scald item type.
 */ 
function _scald_get_info($type, $reset = FALSE) {
  $info = cache_get($type, 'cache_scald');
  if ($reset || empty($info)) {
    $info = array();
    $hook = 'scald_' . $type;
    foreach (module_implements($hook) as $module) {
      $list = module_invoke($module, $hook);
      foreach ($list as &$item) {
        $item['provider'] = $module;
      }
      $info = array_merge($info, $list);
    }
    drupal_alter($hook, $info);
    cache_set($type, $info, 'cache_scald');
  }
  else {
    $info = $info->data;
  }
  return $info;
}

/**
 * Get the defaults options for a specific Atom type.
 */
function scald_atom_defaults($type) {
  $defaults = variable_get('scald_atom_defaults', array());
  if (isset($all[$type])) {
    $default = $all[$type];
  }
  else {
    $types = scald_types();
    $actions = scald_actions();
    $default = new stdClass();
    $default->actions = $actions['view']['bitmask'] + $actions['fetch']['bitmask'];
    $default->description = '';
    $default->thumbnail_source = drupal_get_path('module', 'scald') . '/assets/thumbnail_default.png';
  }
  return $default;
}


/*******************************************************************************
 * SCALD ATOM CRUD
 ******************************************************************************/

/**
 * Save changes to a Scald Atom, or create a new one
 *
 * @param $atom
 *  A Scald Atom Object
 *   At minimum, 'type', 'provider', and 'base_id' (which uniquely identifies a
 *   given Atom) are required.  Additional included values which are keyed by
 *   recognized Scald Atom Object members will be used for those members and
 *   any additional values will be passed along to the Providers.
 * @return
 *   The Scald ID upon successful save
 *   FALSE upon failure
 */
function scald_atom_save(&$atom) {
  // First pass Atom object validation
  $types = scald_types();

  // Verify type
  if (empty($types[$atom->type])) {
    return FALSE;
  }

  // Ensure the Atom Object has all the required members
  if (!isset($atom->publisher)) {
    $atom->publisher = NULL;
  }
  if (!isset($atom->actions)) {
    $atom->actions = NULL;
  }
  if (!isset($atom->title)) {
    $atom->title = '';
  }
  if (!isset($atom->authors)) {
    $atom->authors = array();
  }

  $op = empty($atom->sid) ? 'insert' : 'update';
  $hook = ($op == 'insert') ? 'scald_register_atom' : 'scald_update_atom';

  // The Type Provider can implement some other defaults at this point, but
  //  the Atom Provider may override them.
  module_invoke($types[$atom->type]->provider, $hook, $atom, 'type');

  // Hand the Atom off to the Atom Provider to do additional processing and
  //  population
  // NOTE: Providers explicitly have access to change the Atom's basic members
  //  to allow for hypothetical "dispatch Providers" which would determine the
  //  appropriate Provider and/or characteristics of an Atom upon registration.
  module_invoke($atom->provider, $hook, $atom, 'atom');


  // Another round of member validation is necessary due to the potential for
  //  the Providers to modify them.  By design!
  if (empty($atom->type) || empty($atom->provider)) {
    return FALSE;
  }

  if (empty($types[$atom->type])) {
    return FALSE;
  }

  // Only supply defaults for the Actions bitstring if the Provider did nothing.
  //  Otherwise assume that the bitstring is intentional.
  if (is_null($atom->actions)) {
    $defaults = scald_atom_defaults($atom->type);
    $atom->actions = $defaults->actions;
  }

  // Do "poor-man's" UID validation.
  if (empty($atom->publisher) || !is_numeric($atom->publisher) || !($atom->publisher > 0)) {
    global $user;
    $atom->publisher = $user->uid;
  }

  field_attach_presave('scald_atom', $atom);

  // Put the basic data in the Scald Atom Registry
  $written = drupal_write_record('scald_atoms', $atom);

  if (!$written) {
    return FALSE;
  }

  // Handle a common error in the $values array.

  // Authors
  if (count($atom->authors)) {
    $authors = db_insert('scald_atom_authors')->fields(array('sid', 'aid', 'weight'));

    foreach ($atom->authors as $weight => $author_id) {
      $authors->values(array($atom->sid, $author_id, $weight));
    }

    $authors->execute();
  }

  $function = 'field_attach_' . $op;
  $function('scald_atom', $atom);

  // Transcoding
  // Only fire hook_register_atom() for Transcoder Providers that might be
  //  responsible for transcoding this Atom (based on the currently-configured
  //  Context and Transcoder settings).

  $contexts = scald_contexts();
  $transcoders = scald_transcoders();
  
  foreach ($contexts as $context => $details) {
    if (isset($details['type_format'][$atom->type])) {
      $transcoder = $details['type_format'][$atom->type]['transcoder'];
      $values['@ccontext'] = $context;
      module_invoke($transcoders[$transcoder]['provider'], $hook, $atom, 'transcoder');
    }
  }

  // Clear the render cache
  cache_clear_all($atom->sid . ':', 'cache_scald', TRUE);

  // Clear the static caches
  entity_get_controller('scald_atom')->resetCache(array($atom->sid));

  return $atom->sid;
} // end scald_atom_save()

/**
 * Unregister a Scald Atom
 *
 * @param $sid
 *  The Scald ID of the Atom being unregistered *OR* the Atom object.
 * @return boolean
 *  TRUE is the atom was successfully unregistered, FALSE otherwise
 */
function scald_unregister_atom($sid) {
  if (is_object($sid)) {
    $sid = $sid->sid;
  }

  // If we couldn't get back to the atom id  at this point, we won't be able to
  // unregister the atom, so let's just abort.
  if (!is_numeric($sid)) {
    return FALSE;
  }

  // Force a rebuild to ensure that the most-current instance is being used as
  //  when informing Providers of the impending destruction.
  $atom = scald_fetch($sid, TRUE);

  // If we couldn't fetch the object, abort early too, the atom has already been
  // unregistered.
  if (!is_object($atom)) {
    return FALSE;
  }

  $types = scald_types();
  $transcoders = scald_transcoders();

  // Revoke all permissions on the Atom, making it inaccessible.
  db_update('scald_atoms')
    ->fields(array('actions', 0))
    ->condition('sid', $sid)
    ->execute();

  // Alert the Providers that this Atom is gone
  module_invoke($types[$atom->type]['provider'], 'scald_unregister_atom', $atom, 'type');
  module_invoke($atom->provider, 'scald_unregister_atom', $atom, 'atom');

  foreach (scald_contexts() as $context => $details) {
    if (isset($details['type_format'][$atom->type]) && $transcoder = $details['type_format'][$atom->type]['transcoder']) {
      module_invoke($transcoders[$transcoder]['provider'], 'scald_unregister_atom', $atom, 'transcoder');
    }
  }

  // Clear the memory cache
  scald_is_registered($sid, TRUE);
  // Clear the render cache
  cache_clear_all($sid . ':', 'cache_scald', TRUE);
} // end scald_unregister_atom()



/**
 * Determine if a Scald Atom is registered with Scald Core or not.
 *
 * @param $sid
 *   The Scald ID being tested.
 * @return
 *   A Scald Atom Object if the Scald ID is valid.  The Atom Object is *ONLY*
 *    populated with the following members: type, provider, base_id, actions,
 *    and fetched *set to FALSE*.
 *   FALSE if $sid is not a valid Scald ID (int) or if it does not reference an
 *    Atom.
 */
function scald_is_registered($sid, $rebuild = FALSE) {
  // Argument validation
  if (!is_numeric($sid)) {
    return FALSE;
  }
  $sid = (int) $sid;

  static $scald_atoms;
  if (!isset($scald_atoms)) {
    $scald_atoms = array();
  }

  // Reference the memory cache when appropriate
  if (!$rebuild && isset($scald_atoms[$sid])) {
    return $scald_atoms[$sid];
  }

  // Build the Atom from the db
  $registration_results = db_query("SELECT * FROM {scald_atoms} WHERE sid = :sid", array(':sid' => $sid));
  if (!$registration_results) {
    // Ensure that no Atoms linger improperly post-deletion
    unset($scald_atoms[$sid]);
    return FALSE;
  }
  $atom = $registration_results->fetchObject();

  if (!empty($atom)) {
    $atom->fetched = FALSE;
  }
  else {
    return FALSE;
  }

  $scald_atoms[$sid] = $atom;

  return $scald_atoms[$sid];
} // end scald_is_registered()



/**
 * Load a Scald Atom.
 *
 * @param $sid
 *   The Scald ID of the Atom to load.
 * @param $rebuild
 *   If set to TRUE, the Atom will be reloaded from the DB even if it is already
 *    present in the memory cache.
 * @return
 *   A populated Scald Atom object
 *   FALSE if SID is invalid or if $user is not permitted to fetch the Scald Atom
 */
function scald_fetch($sid, $rebuild = FALSE) {
  // Verify the SID is legit and fetch basic info about the Atom
  $atom = scald_is_registered($sid, $rebuild);
  if (!$atom) {
    return FALSE;
  }


  // Verify that the current user is allowed to fetch this Atom
  if (!scald_action_permitted($atom, 'fetch')) {
    return FALSE;
  }


  // Check the memory cache for the Atom
  static $scald_atoms;
  if (empty($scald_atoms)) {
    $scald_atoms = array();
  }

  if (!$rebuild && isset($scald_atoms[$sid])) {
    return $scald_atoms[$sid];
  }


  // Let the Atom Type Provider handle any defaults
  $types = scald_types();

  module_invoke($types[$atom->type]->provider, 'scald_fetch', $atom, 'type');

  $atom->authors = db_select('scald_atom_authors', 'saa')
    ->fields('saa', array('weight', 'aid'))
    ->condition('saa.sid', $atom->sid)
    ->orderBy('saa.weight')
    ->execute()
    ->fetchAllAssoc('weight');

  $atom->base_entity = NULL;

  module_invoke($atom->provider, 'scald_fetch', $atom, 'atom');

  // If the Providers tried to mess with "protected" Atom object members, fail!
  if ($sid != $atom->sid) {
    return FALSE;
  }

  // Ensure all required Atom members are populated with at minimum default
  //  values.  NOTE: it is assumed that Atom Providers won't be monkeying with
  //  the "essentials" like the Type, Provider, SID, etc.
  $defaults = scald_atom_defaults($atom->type);
  if (empty($atom->file_source)) {
    $atom->file_source = $defaults->file_source;
  }
  if (empty($atom->thumbnail_source)) {
    $atom->thumbnail_source = $defaults->thumbnail_source;
  }
  if (empty($atom->description)) {
    $atom->description = $defaults->description;
  }

  $atom->fetched = TRUE;
  $scald_atoms[$sid] = $atom;

  return $atom;
} // end scald_fetch()



/**
 * Determine if a Scald Atom is fetched
 *
 * @param $atom
 *   The Scald Atom to test
 * @return
 *   TRUE/FALSE
 */
function scald_is_fetched($atom = NULL) {
  return (
    is_object($atom)
    && isset($atom->fetched)
    && $atom->fetched
  );
} // end scald_is_fetched()



/**
 * Find Atoms matching a given set of characteristics.
 *
 * @param $query
 *  A keyed array with one or more of the following keys:
 *    'provider'
 *    'type'
 *    'base_id'
 *    'publisher'
 *    'actions'
 *    'title'
 * @param $fuzzy
 *  A boolean that if set to TRUE broadens the search to include partial matches
 *  on all parameters
 * @param $singular
 *  A boolean that if set to TRUE ensures that only one result is returned.  The
 *   return value is a single SID (scalar, not in an array).
 * @return
 *  An array of SIDs that match the characteristics specified
 *  FALSE on bad input or no results
 */
function scald_search($query = array(), $fuzzy = FALSE, $singular = FALSE) {
  // Argument validation
  if (empty($query) || !is_array($query)) {
    return FALSE;
  }

  $types = scald_types();
  $providers = scald_atom_providers();

  if (!$fuzzy && !empty($query['type']) && !is_array($query['type']) && !in_array($query['type'], array_keys($types))) {
    unset($query['type']);
  }

  if (!empty($query['providers']) && !in_array($query['provider'], $providers)) {
    unset($query['provider']);
  }


  // Build the query & execute
  $wheres = array();
  $data = array();
  foreach ($query as $field => $value) {
    switch ($field) {
      case 'title':
      case 'type':
      case 'base_id':
      case 'provider':
        $placeholder = $fuzzy ? "'%%%s%%'" : "'%s'";
        if (is_array($value)) {
          $condition = db_placeholders($value, 'text');
          $wheres[] = $field . " IN($condition)";
          $data = array_merge($data, $value);
        }
        else {
          if ($fuzzy) {
            $wheres[] = $field ." LIKE '%%%s%%'";
          }
          else {
            $wheres[] = $field ." = '%s'";
          }
          $data[] = $value;
        }
        break; // end 'title/type/base_id/provider'

      case 'publisher':
        $wheres[] = $field . " = %d";
        $data[] = $value;
        break; // end 'publisher'

      case 'actions':
        break; // end 'actions'

      default:
        continue;
    }
  }

  // @@@TODO: Use a pager_query() call here?

  $search_results = db_query(
    "
      SELECT
        sid
      FROM
        {scald_atoms}
      WHERE "
      . implode(' AND ', $wheres)
      . ($singular ? " LIMIT 1" : '')
    , $data
  );

  // Compose and return results
  if (!$search_results) {
    return FALSE;
  }

  if ($singular) {
    return db_result($search_results);
  }

  $sids = array();
  while ($sid_raw = db_fetch_array($search_results)) {
    $sids[] = $sid_raw['sid'];
  }

  return $sids;
} // end scald_search()






/*******************************************************************************
 * SCALD AUTHORS
 ******************************************************************************/

/**
 * Get an Author ID from Scald Core.
 * This will first check if an author matching the $data passed as an argument
 * exists, and return it if it does. If it doesn't, then it will try to create
 * a new author from this data.
 *
 * @param $data
 *  A keyed array with the following possible keys:
 *   'name', the full name; no first/last/etc. distinction. (required)
 *   'uid', A Drupal User ID. (optional)
 *   'url', A URL by which to find out more about the Author. (optional)
 *    NOTE: If this element is omitted for an array which has 'uid' set, the
 *     path 'user/<uid>' is assumed and supplied.  Set 'url' to an empty string
 *     to avoid this behavior.
 * @return
 *  The Author ID upon success.
 *  FALSE upon failure
 */
function scald_author_get_id($data = array()) {
  // Validate arguments
  if (empty($data) || empty($data['name'])) {
    return FALSE;
  }

  // Build SQL conditions
  $sets = array();
  $sql_data = array();
  foreach ($data as $field => $value) {
    switch ($field) {
      case 'name':
        $sets[] = 'name = \'%s\'';
        $sql_data[] = $value;
        break; // end 'name'

      case 'uid':
        $sets[] = 'uid = %d';
        $sql_data[] = $value;
        if (!isset($data['url'])) {
          $sets[] = 'url = \'' . url('user') . '/%d\'';
          $sql_data[] = $value;
        }
        break; // end 'uid'

      case 'url':
        $sets[] = 'url = \'%s\'';
        $sql_data[] = $value;
        break; // end 'url'

      default:
        continue;
    }
  }

  // Look for an existing author in the database.
  $aid = db_result(db_query(
    "
      SELECT aid FROM
        {scald_authors}
      WHERE "
        . implode(' AND ', $sets),
    $sql_data
  ));
  if ($aid) {
    return $aid;
  }

  // If no author matched those criteria, then, try to insert a new one.
  if (!db_query(
    "
      INSERT INTO
        {scald_authors}
      SET "
        . implode(', ', $sets),
    $sql_data
  )) {
    return FALSE;
  }

  return db_last_insert_id('scald_authors', 'aid');
} // end scald_author_get_id()

/**
 * Register an Author with Scald Core.
 *
 * @param $data
 *  A keyed array with the following possible keys:
 *   'name', the full name; no first/last/etc. distinction. (required)
 *   'uid', A Drupal User ID. (optional)
 *   'url', A URL by which to find out more about the Author. (optional)
 *    NOTE: If this element is omitted for an array which has 'uid' set, the
 *     path 'user/<uid>' is assumed and supplied.  Set 'url' to an empty string
 *     to avoid this behavior.
 * @return
 *  The Author ID upon success.
 *  FALSE upon failure
 */
function scald_register_author($data = array()) {
  // Validate arguments
  if (empty($data) || empty($data['name'])) {
    return FALSE;
  }

  // Prefill the URL if we have and uid and no url
  if (empty($data['url']) && !empty($data['uid'])) {
    $data['url'] = 'user/' . $data['uid'];
  }

  return db_insert('scald_authors')
    ->fields($data)
    ->execute();
} // end scald_register_author()



/**
 * Updates an Author's details.
 *
 * @param $aid
 *  The Author ID of the Author whose information is being updated.
 * @param $data
 *  A keyed array with the same elements as the $data parameter from
 *   scald_register_author().  Any elements not present will not be updated.
 * @return
 *  A boolean indicating success or failure
 */
function scald_update_author($aid, $data = array()) {
  // Validate arguments
  if (empty($aid) || !is_numeric($aid) || empty($data)) {
    return FALSE;
  }

  $sets = array();
  $sql_data = array();
  foreach ($data as $field => $value) {
    switch ($field) {
      case 'name':
        $sets[] = 'name = \'%s\'';
        $sql_data[] = $value;
        break; // end 'name'

      case 'uid':
        $sets[] = 'uid = %d';
        $sql_data[] = $value;
        if (!isset($data['url'])) {
          $sets[] = 'url = \'' . url('user') . '/%d\'';
          $sql_data[] = $value;
        }
        break; // end 'uid'

      case 'url':
        $sets[] = 'url = \'%s\'';
        $sql_data[] = $value;
        break; // end 'url'

      default:
        continue;
    }
  }
  $sql_data[] = $aid;

  if (!db_query(
    "
      UPDATE
        {scald_authors}
      SET "
        . implode(', ', $sets) . "
      WHERE
        aid = %d
    ",
    $sql_data
  )) {
    return FALSE;
  }

} // end scald_update_author()



/**
 * Unregister an Author with Scald Core.
 *
 * @param $aid
 *  The Author ID of the Author to remove.
 * @return
 *  Boolean representing the success or failure of the unregistration.
 */
function scald_unregister_author($aid = NULL) {
  if (!is_numeric($aid)) {
    return FALSE;
  }

  db_query("DELETE FROM {scald_authors} WHERE aid = %d", $aid);
  db_query("DELETE FROM {scald_atom_authors} WHERE aid = %d", $aid);

  return TRUE;
} // end scald_unregister_author()



/**
 * Determine the User that corresponds to an Author ID.
 *
 * @param $aid
 *  The Scald Author ID of the Author in question
 * @param
 *  The Drupal User ID of the user who is registered as the Author with $aid.
 *  FALSE upon failure.
 */
function scald_aid_to_uid($aid) {
  return db_result(db_query("SELECT uid FROM {scald_authors} WHERE aid = %d", $aid));
} // end scald_aid_to_uid()



/**
 * Determine the Author ID that corresponds to a User ID.
 *
 * @param $uid
 *  The Drupal User ID of the user in question.  Defaults to the UID of the
 *   current user.
 * @return
 *  The Scald Author ID of the Author record that corresponds to the Drupal
 *  user in question.  FALSE upon failure.
 */
function scald_uid_to_aid($uid = NULL) {
  if (is_null($uid)) {
    global $user;
    $uid = $user->uid;
  }
  return db_result(db_query("SELECT aid FROM {scald_authors} WHERE uid = %d", $uid));
} // end scald_uid_to_aid()






/*******************************************************************************
 * SCALD CONVERSION UTILITIES
 ******************************************************************************/

/**
 * Process a text string and replace Scald Atom Shorthand (SAS) with rendered
 *  Scald Atoms.
 *
 * Looks for strings along the lines of [scald=SID:context-slug options].
 *
 * @see scald_rendered_to_sas
 *
 * @param $string
 *   A text string to be processed.
 * @param $context
 *   A Scald Context.  If $override is FALSE, this Context will only be used to
 *    render the included Scald Atoms if the SAS does not specify a valid Scald
 *    Context.  Defaults to 'title', which is a Scald Context provided by Scald
 *    Core and therefore guaranteed to be registered.
 * @param $override
 *   A boolean used to determine if the Scald Context specified in the SAS
 *    should be used or not.
 * @return
 *   The same text string, but with
 */
function scald_sas_to_rendered($string, $context = NULL, $override = FALSE) {
  if (empty($context)) {
    $context = 'title';
  }

  global $_scald_override;
  $_scald_override = $override;
  $rendered = preg_replace_callback(
    SCALD_SAS_MATCH_PATTERN,
    create_function(
      '$matches',
      '
        global $_scald_override;
        return scald_render(
          $matches[1],
          (!empty($matches[2]) && !$_scald_override ? $matches[2] : \'' . $context . '\'),
          (!empty($matches[3]) ? $matches[3] : NULL)
        );
      '
    ),
    $string
  );

  unset($_scald_override);
  return $rendered;
} // end scald_sas_to_rendered()



/**
 * Determine atoms (expressed as SAS) embedded in a string.
 *
 * @param $string
 *  The string to search for SAS
 * @return
 *  An array of SIDs which are included in the string in SAS form.
 */
function scald_included($string) {
  $matches = array();
  if (!preg_match_all(
    SCALD_SAS_MATCH_PATTERN,
    $string,
    $matches
  )) {
    return array();
  }

  return $matches[1];
} // end scald_included()



/**
 * Process a text string and replace rendered Scald Atoms with Scald Atom
 *  Shorthand (SAS).
 *
 * @see scald_sas_to_rendered
 *
 * NOTE: Scald Core only contains an implementation for parsing Scald Atoms
 *  rendered in XHTML.  Additional implementations can be supplied by
 *  implementing hook_scald_rendered_to_sas_RENDER_LANGUAGE()
 *
 * NOTE: The Scald Core implementation of parsing for XHTML *assumes* that the
 *  standard Scald classes are attached to the outermost (containing) HTML
 *  element.  If a Scald Context does not produce output matching this format
 *  then this function will fail to detect and replace the Scald Atoms rendered
 *  by that Context.  See docs/scald_overview.txt and
 *  docs/scald_provider_api.txt for additional details.  Also see the Context
 *  section in the Scald Administration pages for a tool to detect which Scald
 *  Contexts will not produce output which can be parsed by this function.
 *
 * @param $string
 *   A text string to be processed.
 * @param $render_language
 *   The expected format of $text.  Should correspond to the render_language
 *    specified by Scald Contexts.  Defaults to XHTML.
 * @return
 *  The source string with all rendered Scald Atoms replaced with Scald Atom
 *   Shorthand (SAS).
 */
function scald_rendered_to_sas($string, $render_language = 'XHTML') {
  // If Scald Core can't handle it, maybe a Scald Provider can.
  // NOTE: This will probably fail if more than one Scald Provider implements
  //        support for the same render language.
  if ($render_language != 'XHTML') {
    $strings = module_invoke_all('scald_rendered_to_sas_' . $render_language, $string);
    return $strings[0];
  }

  return preg_replace_callback(
    SCALD_RENDERED_MATCH_PATTERN,
    create_function(
      '$matches',
      '
        return \'[scald=\' . $matches[1] . (!empty($matches[2]) ? \':\' . $matches[2] : \'\') . (!empty($matches[3]) ? \' \' . $matches[3] : \'\') . \']\';
      '
    ),
    $string
  );
} // end scald_rendered_to_sas()






/*******************************************************************************
 * SCALD ACTIONS & LICENSES
 ******************************************************************************/

/**
 * Determine the Scald Actions Bitstring for a given Atom for a given User.
 *
 * @param $atom
 *   A Scald Atom
 * @param $account
 *   A Drupal user account
 *   Defaults to the current $user
 * @return
 *   A Scald Actions Bitstring
 *   FALSE if the Atom is invalid
 */
function scald_user_actions($atom, $account = NULL) {
  global $user;

  // Argument validation
  if (is_null($account)) {
    $account = $user;
  }

  // Default to Anonymous perms if no action bitstring is set.  Also handle the
  //  special subcase of the Anonymous user.
  //
  // NOTE: This is necessary because $user is *not* the result of a user_load()
  //  and so defaults must be defined at first use. Testing for the member's
  //  existance and then modifying the $user object directly (as appropriate)
  //  ensures that the cost of a query is saved the next time an access check is
  //  executed for the current user during this session.
  if (!isset($account->scald_actions)) {
    // Note that db_result() will conveniently fail to FALSE which will prohibit
    //  the user from completing *any* Actions.  Since the Admin interface only
    //  shows Roles which have the "use scald" permission (and therefore the
    //  {scald_role_actions} table only contains Roles which have that
    //  permission), checking for said permission is not necessary (thus saving
    //  a fairly expensive check).
    $account->scald_actions = db_query("
      SELECT
        actions
      FROM
        {scald_role_actions}
      WHERE
        rid = :rid",
      array(':rid' => DRUPAL_ANONYMOUS_RID))->fetchCol();
    if ($account->uid == $user->uid) {
      $user->scald_actions = $account->scald_actions;
    }
  }

  // NOTE: Not using scald_is_fetched here because Action validation can (and
  //  should) be done prior to fetching.  However, it is assumed that this $atom
  //  is *at least* the result of a scald_is_registered() call.
  if (!is_object($atom) || !isset($atom->actions)) {
    return FALSE;
  }

  // The Account in question belongs to the Scald Publisher of this Atom
  if ($atom->publisher == $account->uid) {
    $account->scald_actions = $account->scald_actions | variable_get('scald_actions_publisher', 0);
  }

  // Check for the "admin bit" being set in *either* the Atom or the User Action
  //  bitstring and if it is set, OR the two rather than ANDing them.
  return
    (
      $atom->actions & SCALD_ACTIONS_ADMIN_BIT
      || $account->scald_actions & SCALD_ACTIONS_ADMIN_BIT
    )
    ? $atom->actions | $account->scald_actions
    : $atom->actions & $account->scald_actions;
} // end scald_actions()



/**
 * Determines if a given User can act on a given Atom in a given way.
 *
 * @@@TODO: Implement an optional batch mode which takes an array of Scald
 *          Actions.
 *
 * @param $atom
 *   A Scald Atom
 * @param $action
 *   A Scald Action slug
 * @param $account
 *   A Drupal user account
 *   Defaults to the current $user
 * @return
 *   TRUE/FALSE
 */
function scald_action_permitted($atom, $action = 'fetch', $account = NULL) {
  $actions = scald_actions();
  if (empty($actions[$action])) {
    return FALSE;
  }

  return (bool) (scald_user_actions($atom, $account) & $actions[$action]['bitmask']);
} // end scald_action_permitted()






/*******************************************************************************
 * SCALD CONTEXTS AND RENDERING
 ******************************************************************************/

/**
 * Prepare a Scald Atom for rendering
 *
 */
function scald_prerender(&$atom, $context, $options = NULL) {
  $types = scald_types();
  $contexts = scald_contexts();
  $transcoders = scald_transcoders();
  $actions = scald_actions();
  $context_config = $contexts[$context];

  // Build the portion of the Rendered member which Providers are expected to
  //  manipulate.
  $atom->rendered = new stdClass;
  $atom->rendered->sid = $atom->sid;
  $atom->rendered->title = $atom->title;
  $atom->rendered->file_source_url = empty($atom->file_source) ? NULL : url($atom->file_source);
  $atom->rendered->file_transcoded_url = NULL;
  $atom->rendered->thumbnail_source_url = file_create_url($atom->thumbnail_source);
  $atom->rendered->description = $atom->description;
  $atom->rendered->nocache = FALSE;

  // Type & Atom prerenders
  module_invoke($types[$atom->type]->provider, 'scald_prerender', $atom, $context, $options, 'type');
  module_invoke($atom->provider, 'scald_prerender', $atom, $context, $options, 'atom');

  // Transcoder Provider prerender -- only if there is a Transcoder specified
  //  for this Context.
  //  POPULATES: $atom->rendered->file_transcoded_url
  if (!empty($context_config['type_format']) && !empty($context_config['type_format'][$atom->type])) {
    module_invoke($transcoders[$context_config['type_format'][$atom->type]['transcoder']]['provider'], 'scald_prerender', $atom, $context, $options, 'transcoder');
  }

  // Context prerender
  module_invoke($context_config['provider'], 'scald_prerender', $atom, $context, $options, 'context');

  // Populate default rendered members & validate other rendered members.
  $atom->rendered->title = check_plain($atom->rendered->title);
  $atom->rendered->description = filter_xss($atom->rendered->description); 
  $atom->rendered->type = $types[$atom->type]->title;

  // Actions
  $atom->rendered->actions = array();
  $current_actions = scald_actions($atom) & ~SCALD_ACTIONS_ADMIN_BIT; // Remove the Admin bit as it is irrelevant for rendering purposes
  foreach ($actions as $slug => $details) {
    if ($current_actions & $details['bitmask']) {
      $atom->rendered->actions[] = array(
        'title' => $details['title'],
        'path'  => 'scald/actions/' . $slug . '/' . $atom->sid,
        'link'  => l($details['title'], 'scald/actions/' . $slug . '/' . $atom->sid),
      );
    }
  }

  // Authors
  $atom->rendered->authors = array();
  if (!empty($atom->authors)) {
    $authors_details = db_select('scald_authors', 'sa')
      ->fields('sa', array('aid', 'name', 'uid', 'url'))
      ->condition('sa.aid', $atom->authors)
      ->execute()
      ->fetchAllAssoc('aid');
    foreach ($atom->authors as $weight => $aid) {
      $author = $authors_details[$aid];
      if ($author['url']) {
        $author['link'] = l($author['name'], $author['url']);
      }
      else {
        $author['link'] = check_plain($author['name']);
      }
      $atom->rendered->authors[$weight] = $author;
    }
  }

  // User
  // NOTE: This query is much faster than a user_load() (no JOIN)
  $name = db_select('users', 'u')
    ->fields('u', array('name'))
    ->condition('u.uid', $atom->publisher)
    ->execute()
    ->fetchField();

  $atom->rendered->publisher = array(
    'uid'  => $atom->publisher,
    'name' => $name,
    'path' => 'user/' . $atom->publisher,
    'link' => l($name, 'user/' . $atom->publisher),
  );

} // end scald_prerender()



/**
 * Render a Scald Atom
 *
 * "Rendering" takes an Atom and generates output (typically XHTML) based on the
 *  "Context" which is specified.  The Context is essentially a template.
 *
 * NOTE: scald_render() gets called recursively until a viable output is
 *  generated.  It may return FALSE on a given call, but it will ultimately fall
 *  back to the 'title' Context which is provided by Scald Core and *always*
 *  generates *something*.  Even if a
 *
 * @param $sid
 *   A Scald ID *OR* a Scald Atom.
 * @param $context
 *   A valid Scald Context slug (a text string)
 * @param $options
 *   An optional text string specifying additional Scald Context-specific
 *    options that get passed to the Scald Context for rendering (e.g. a
 *    mechanism for specifying the size of an image).
 * @param $rebuild
 *   Set to true to force a rebuild of the rendering.
 * @return
 *   The rendered Scald Atom (usually an XHTML string ready for display)
 *   FALSE if the rendering failed for whatever reason
 */
function scald_render($sid, $context, $options = NULL, $rebuild = FALSE) {
  // Argument validation
  if (!is_numeric($sid)) {
    if (!empty($sid->sid)) {
      $atom = $sid;
      $sid  = $atom->sid;
    }
    else {
      return FALSE;
    }
  }

  // Load the Atom Object in order to use it for determining the current Actions
  //  bitstring and for recursive scald_render() calls.
  $atom_reg = scald_is_registered($sid, $rebuild);
  if (empty($atom)) {
    $atom = $atom_reg;
  }

  // SID doesn't correspond to a registered Atom; drop through to render the
  //  "Invalid ID" message.
  if (empty($atom_reg)) {
    return scald_scald_render($atom_reg, 'invalid-id');
  }

  // Drop through to no-access rendering if current user can't view.
  if (!scald_action_permitted($atom, 'view')) {
    return scald_scald_render($atom, 'no-access');
  }

  $contexts = scald_contexts();

  // In the event of an invalid Context, initiate fallbacks.  Immediate return
  //  avoids caching a different rendering as the specified Context.
  if (empty($contexts[$context])) {
    return scald_render($atom, _scald_context_fallback($type, $context), $options, $rebuild);
  }


  // Check the cache unless explicitly rebuilding the rendering of the Atom
  $cache_id = $sid
	    . ':' . $context
	    . ':' . scald_actions($atom)
	    . (is_null($options) ? '' : ':' . $options);
  if (!$rebuild && !variable_get('scald_always_rebuild', FALSE)) {
    $cache = cache_get($cache_id, 'cache_scald');
    if (!empty($cache)) {
      return $cache->data;
    }
  }


  // Either a cache miss or an explicit rebuild.  Pull in the rest of the Atom.
  if (!scald_is_fetched($atom)) {
    $atom = scald_fetch($sid);
  }

  scald_prerender($atom, $context, $options);

  // Context Provider does the final rendering
  $rendered = module_invoke($contexts[$context]['provider'], 'scald_render', $atom, $context, $options);

  // The Context exists but rendering is failing hard for some reason.  Output
  //  still needs to be ensured, however.  Also note that an empty string is
  //  valid output.  However, hook_scald_render() should return FALSE upon
  //  failure and module_invoke() will return NULL if the function does not
  //  exist.
  if ($rendered === FALSE || is_null($rendered)) {
    return scald_render($atom, _scald_context_fallback($atom->type, $context), $options, $rebuild);
  }

  // For so-called "parsable" Contexts, ensure a standard format for the
  //  enclosing comments.
  if ($contexts[$context]['parseable']) {
    $rendered = '<!-- scald=' . $atom->sid . ':' . $context . (!empty($options) ? ' ' . $options : '') . ' -->' . $rendered . '<!-- END scald=' . $atom->sid . ' -->';
  }

  // Only cache the Atom if Contexts, etc. have not indicated that the rendering
  //  is not cacheable (e.g. it contains the current user's username).
  if (!$atom->rendered->nocache) {
    // Note that cached renderings of an Atom will stick around until
    //  scald_update_atom() is called on the Atom.  This is usually the
    //  responsibility of the Atom Provider as it has the best idea when the base
    //  entity is changing.
    cache_set($cache_id, $rendered, 'cache_scald', CACHE_PERMANENT);
  }

  return $rendered;
} // end scald_render()



/**
 * Determine the next Context in the Context fallback order for this Scald
 *  Scald Unified Type.
 *
 * @param $type
 *   A Scald Unified Type slug
 * @param $context
 *   The Scald Context which is being fallen back from.
 * @return
 *   The next Scald Context in the fallback order
 */
function _scald_context_fallback($type, $context) {
  $contexts = scald_contexts();
  $render_language = !empty($contexts[$context]) ? $contexts[$context]['render_language'] : 'XHTML';
  $scald_context_fallbacks = variable_get('scald_context_fallbacks', 0);

  // Generate a flat array of in-order fallback Contexts.  The highest-index
  //  Context is the most generic and least likely to fail.
  $fallbacks = array_merge(
    !empty($scald_context_fallbacks[$render_language][$type]) ? $scald_context_fallbacks[$render_language][$type] : array(),
    !empty($scald_context_fallbacks[$render_language]['@default']) ? $scald_context_fallbacks[$render_language]['@default'] : array(),
    $scald_context_fallbacks['@default'],
    array('title')  // Included to *ENSURE* that recursion terminates
  );

  // Determine where in the order the current Context falls so that "next" has a
  //  definitive meaning.
  $current_index = array_search($context, $fallbacks);
  if (!$current_index) {
    $current_index = -1;
  }

  return $fallbacks[$current_index+1];
} // end _scald_context_fallback()






/*******************************************************************************
 * SCALD HOOK IMPLEMENTATIONS
 ******************************************************************************/

/**
 * Implements hook_scald_contexts.
 */
function scald_scald_contexts() {
  return array(
    'debug' => array(
      'title'           => t('Debuging Display'),
      'description'     => t('A useful debugging display of a Scald Atom.'),
      'render_language' => 'XHTML',
      'parseable'       => FALSE,
      'formats'         => array(
        '<all>' => 'passthrough',
      ),
    ),
    'no-access' => array(
      'title'           => t('No Access'),
      'description'     => t('Built-in Context used when an Atom cannot be viewed by the current User.'),
      'render_language' => 'XHTML',
      'parseable'       => TRUE,
      'formats'         => array(),
    ),
    'invalid-id' => array(
      'title'           => t('Invalid ID'),
      'description'     => t('Built-in Context used when an Invalid Scald ID is provided to the rendering stack.'),
      'render_language' => 'XHTML',
      'parseable'       => TRUE,
      'formats'         => array(),
    ),
    'deleted'   => array(
      'title'           => t('Deleted'),
      'description'     => t('Built-in Context used when an Atom is no longer present in the Registry (but once was).'),
      'render_language' => 'XHTML',
      'parseable'       => TRUE,
      'formats'         => array(),
    ),
    'title'     => array(
      'title'           => t('Title'),
      'description'     => t('Literally *just* the title as plain text, though the language is specified as XHTML for simplicity.'),
      'render_language' => 'XHTML',
      'parseable'       => FALSE,
      'formats'         => array(),
    ),
  );
}

/**
 * Implements hook_scald_transcoders.
 */
function scald_scald_transcoders() {
  return array(
    'passthrough' => array(
      'title'       => t('Passthrough'),
      'description' => t('<see scald.admin.inc>'),
      'formats'     => array(
        'type-a' => 'passthrough',
        'type-b' => 'passthrough',
        // All currently-registered Scald Unified Types would be listed
      ),
    ),
  );
}

/**
 * Implements hook_scald_actions.
 */
function scald_scald_actions() {
  return array(
    // @admin is *always* the highest bit
    '@admin' => Array(
      'title'       => t('Admin Mode'),
      'description' => t('<see scald.admin.inc>'),
    ),
    'fetch' => array(
      'title'       => t('Fetch'),
      'description' => t('<see scald.admin.inc>'),
    ),
    'edit' => array(
      'title'       => t('Edit'),
      'description' => t('Edit the details of a Scald Atom'),
    ),
    'view'       => array(
      'title'       => t('View'),
      'description' => t('View a Scald Atom on-site'),
    ),
    'delete'       => array(
      'title'       => t('Delete'),
      'description' => t('Delete (unregister) a Scald Atom'),
    ),
  );
}

/**
 * Implementation of hook_scald_prerender().
 *
 * Scald Core implements this hook for its role as a Scald Atom Provider of
 *  Atoms of Scald Unified Type 'composite', for its role as a Scald Context
 *  Provider of Scald Contexts 'debug', 'no-access', 'invalid-id', 'deleted',
 *  'title', and for its role as a Scald Transcoder Provider of Scald Transcoder
 *  'passthrough'.
 *
 * @param $atom
 *  The Scald Atom object to prepare for rendering.
 * @param $mode
 *  A string indicating which mode the prerender function is being called in (
 *   'type', 'atom', 'context', or 'transcoder').
 * @param $context
 *  The Scald Context slug.  Must be optional since Scald Core implements
 *   multiple Providers which require hook_scald_prerender().
 * @param $options
 *  A string which represents any Context options.  Must be optional since Scald
 *   Core implements multiple Providers which require hook_scald_prerender().
 * @return
 *  None; $atom->rendered should be adjusted as appropriate
 */
function scald_scald_prerender($atom, $mode, $context = NULL, $options = NULL) {
  switch ($mode) {
    case 'type':
      break; // end 'type'

    case 'context':
      switch ($context) {
        case 'debug':
          break;

        case 'no-access':
          break;

        case 'invalid-id':
          break;

        case 'deleted':
          break;

        case 'title':
          break;
      }
      break; // end 'context'

    case 'transcoder':
      $atom->rendered->file_transcoded_url = url($atom->file_source);
      break; // end 'transcoder'
  }
} // end scald_scald_prerender()



/**
 * Implementation of hook_scald_render().
 */
function scald_scald_render($atom, $context, $options = NULL) {
  switch ($context) {
    case 'debug':
      return '<pre class="debug">' . print_r($atom, TRUE) . '</pre>';
      break;

    case 'no-access':
      return theme('scald_render_error', $context, t('You do not have access to view this Atom.'));
      break;

    case 'invalid-id':
      return theme('scald_render_error', $context, t('Invalid Scald ID.'));
      break;

    case 'deleted':
      return theme('scald_render_error', $context, t('Atom deleted!'));
      break;

    case 'title':
    default:
      return $atom->rendered->title;
      break;
  }
} // end scald_scald_render()



/**
 * Implementation of hook_scald_action().
 */
function scald_scald_action($atom, $action) {
  switch($action) {
    case 'fetch':
      // No specific functionality necessary here
      break;
    case 'edit':
      // @@@TODO: Implement this as a per-atom-provider kind of thing if possible.
      break;
    case 'view':
      // @@@TODO: Implement as a scald_render() call?
      break;
    case 'delete':
      // @@@TODO: Implement a lightweight confirmation interface and then scald_unregister_atom()
      break;
  }
} // end scald_scald_action()

/*******************************************************************************
 * DRUPAL HOOK IMPLEMENTATIONS
 ******************************************************************************/

/**
 * Implements hook_entity_info.
 *
 * Define a new entity type for the Atoms.
 */
function scald_entity_info() {
  $return = array(
    'scald_atom' => array(
      'label' => t('Atoms'),
      'base table' => 'scald_atoms',
      'uri callback' => 'scald_atom_uri',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'sid',
        'bundle' => 'type',
        'label' => 'title',
      ),
      'bundle keys' => array(
        'bundle' => 'type'
      ),
      'bundles' => array(),
      'view modes' => array()
    )
  );

  $contexts = scald_contexts();
  foreach ($contexts as $slug => $context) {
    $return['scald_atom']['view modes'][$slug] = array(
      'label' => $context['title'],
      'custom settings' => FALSE,
    );
  }

  $types = scald_types();
  foreach ($types as $type => $info) {
    $return['scald_atom']['bundles'][$type] = array(
      'label' => $info->title,
      'admin' => array(
        'path' => 'admin/structure/scald/%scald_type',
        'bundle argument' => 3,
        'real path' => 'admin/structure/scald/' . $type,
        'access arguments' => array('administer content types')
      )
    );
  }

  return $return;
}

/**
 * Implements hook_field_extra_fields.
 */
function scald_field_extra_fields () {
  $extra = array();
  foreach (scald_types() as $slug => $type) {
    $extra['scald_atom'][$slug] = array(
      'form' => array(
        'title' => array(
          'label' => 'Title',
          'description' => 'Atom title - Scald module element',
          'weight' => -5,
        )
      )
    );
  }
  return $extra;
}


/**
 * Implementation of hook_perm().
 *
 * NOTE: Scald Actions permissions are *not* assigned using the normal Drupal
 *  permissions interface.  Instead they are managed separately through the
 *  Scald Admin Interface.  Actions are assigned to Drupal User Roles there.
 */
function scald_perm() {
  return array(
    'administer scald',		// Grants access to the Scald Admin Interface
    'debug scald',        // Grants access to the Scald Debugging Console
    'use scald',          // Grants access to the basic functioning of Scald (registering Atoms, etc.)
  );
} // end scald_perm()


/**
 * Implementation of hook_menu().
 */
function scald_menu() {
  $items = array();

  $items['scald/debug/%'] = array(
    'title'            => 'Scald Debugging Console',
    'page callback'    => 'scald_debug_console',
    'page arguments'   => array(2),
    'access callback'  => 'user_access',
    'access arguments' => array('debug scald'),
    'file'             => 'scald.debug.inc',
    'type'             => MENU_NORMAL_ITEM,
  );

  $items['admin/content/atoms'] = array(
    'title'             => 'Atoms',
    'weight'            => -60,
    'page callback'     => 'scald_admin_atoms',
    'access callback'   => 'user_access',
    'access arguments'  => array('administer scald'),
    'file'              => 'scald.admin.inc',
    'type'              => MENU_LOCAL_TASK,
  );
  $items['admin/structure/scald'] = array(
    'title'             => 'Scald',
    'description'       => 'Manage Scald Atom Types, Contexts, and their associated settings.',
    'page callback'     => 'scald_admin_dashboard',
    'access callback'   => 'user_access',
    'access arguments'  => array('administer scald'),
    'file'              => 'scald.admin.inc',
    'type'              => MENU_NORMAL_ITEM,
  );
  $items['admin/structure/scald/%scald_type'] = array(
    'title'             => 'Type',
    'title callback'    => 'scald_type_name',
    'title arguments'   => array(3),
    'weight'            => -80,
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('scald_admin_type_form', 3),
    'access callback'   => 'user_access',
    'access arguments'  => array('administer scald'),
    'file'              => 'scald.admin.inc',
    'type'              => MENU_NORMAL_ITEM,
  );
  $items['admin/structure/scald/%scald_type/edit'] = array(
    'title'             => t('Edit'),
    'type'              => MENU_DEFAULT_LOCAL_TASK,
    'weight'            => -20,
  );
  $items['admin/structure/scald/%scald_type/contexts'] = array(
    'title'             => 'Contexts',
    'weight'            => 40,
    'page callback'     => 'scald_admin_contexts',
    'page arguments'    => array(3),
    'access callback'   => 'user_access',
    'access arguments'  => array('administer scald'),
    'file'              => 'scald.admin.inc',
    'type'              => MENU_LOCAL_TASK,
  );
  $items['admin/structure/scald/settings'] = array(
    'title'             => 'Settings',
    'weight'            => 20,
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('scald_settings_form'),
    'access callback'   => 'user_access',
    'access arguments'  => array('administer scald'),
    'file'              => 'scald.admin.inc',
    'type'              => MENU_LOCAL_TASK,
  );
  $items['atoms/add'] = array(
    'title' => 'Create Atom',
    'page callback' => 'scald_atom_add',
    'access arguments' => array('administer scald'),
    'file' => 'scald.pages.inc'

  );
  $items['atoms/add/%scald_type'] = array(
    'title' => 'Create Atom',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('scald_atom_add_form', 2),
    'access arguments' => array('administer scald'),
    'file' => 'scald.pages.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
} // end scald_menu()

function scald_type_load($type) {
  $types = scald_types();
  if (isset($types[$type])) {
    return $types[$type];
  }
  return FALSE;
}

function scald_type_name($type) {
  return $type->title;
}



/**
 * Implementation of hook_theme()
 */
function scald_theme($existing, $type, $theme, $path) {
  return array(
    'scald_render_error' => array(
      'arguments' => array('type' => NULL, 'message' => NULL)
    )
  );
}


/**
 * Implementation of hook_filter().
 */
function scald_filter($op, $delta = 0, $format = -1, $text = '', $cache_id = 0) {
  switch ($op) {
    case 'list':
      return array(0 => t('Scald Atom Shorthand Filter'));
      break;

    case 'no cache':
      // Caching is disabled to ensure that current renderings of Atoms are
      //  returned.  Invalidating specific {cache_filter} entries is nearly
      //  impossible due to a hash of the text-to-filter being used as a key.
      //  Because Scald caches Atom renderings, the performance hit should be
      //  relatively insignficant.
      return TRUE;
      break;

    case 'description':
      return t('Allows users to include Scald Atom Shorthand (SAS) in a textarea and have the Atoms rendered in a particular Scald Context.  Often combined with WYSIWYG editors and custom textarea parsing to automatically generate the SAS.');
      break;

    case 'prepare':
      return $text;
      break;

    case 'process':
      $override = variable_get('scald_filter_sas_' . $format . '_override', FALSE);
      $context = variable_get('scald_filter_sas_' . $format . '_context', FALSE);
      return scald_sas_to_rendered($text, $context, $override);
      break;

    case 'settings':
      $context_options = array();
      $contexts = scald_contexts();
      foreach ($contexts as $name => $context) {
        $context_options[$name] = $context['title'];
      }

      $form['filter_sas'] = array(
        '#type'        => 'fieldset',
        '#title'       => t('Scald Atom Shorthand Filter'),
        '#collapsible' => TRUE,
        '#collapsed'   => FALSE,
      );
      $form['filter_sas']['scald_filter_sas_' . $format . '_context'] = array(
        '#type'          => 'select',
        '#title'         => t('Scald Context'),
        '#description'   => t('Choose a Scald Context to use for rendering Scald Atoms included in the text using Scald Atom Shorthand.'),
        '#default_value' => variable_get('scald_filter_sas_' . $format . '_context', 'title'),
        '#options'       => $context_options,
      );
      $form['filter_sas']['scald_filter_sas_' . $format . '_override'] = array(
        '#type'          => 'checkbox',
        '#title'         => t('Override specified Context'),
        '#description'   => t('If checked, the Scald Context specified above will be used even if there is a Context is specified the Scald Atom Shorthand.'),
        '#default_value' => variable_get('scald_filter_sas_' . $format . '_override', FALSE),
      );
      return $form;
      break;

    default:
      return $text;
      break;
  }
} // end scald_filter()



/**
 * Implementation of hook_filter_tips().
 */
function scald_filter_tips($delta, $format, $long = FALSE) {
  if ($long) {
    return t('Any instance of Scald Atom Shorthand (SAS) will be replaced with a rendered Scald Atom.  SAS can take any of the following formats: [scald=SID], [scald=SID:context], or [scald=SID:context context-options].  SID is the Scald ID, context is a context-slug, and context-options are additional formatting clues to give to the Context.');
  }
  return t('You may include Scald Atom Shorthand such as [scald=12].  NOTE: WYSIWYG or rich-text editors often handle Scald Atom Shorthand automatically and manually including it is not necessary if such an editor is in use.');
} // end scald_filter_tips()



/**
 * Implementation of hook_user().
 */
function scald_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    case 'delete':
      $aid = scald_uid_to_aid($account->uid);
      if ($aid) {
        scald_unregister_author($aid);
      }
      break;
    case 'load':
      // See scald_actions() for handling of defaults for scald_actions and an
      //  explanation of why such handling is not done here.
      break;
    case 'insert':
    case 'update':
      // All Drupal users need to registered as Scald Authors
      $aid = scald_uid_to_aid($account->uid);
      $author_data = array(
        'name'  => $account->name,
        'uid'   => $account->uid,
      );
      if ($aid) {
        scald_update_author($aid, $author_data);
      }
      else {
        scald_register_author($author_data);
      }

      // Fetch action bitstring components by User Role and then combine in
      //  in preparation for saving to db.
      $edit['scald_actions'] = 0;
      $roles = isset($edit['roles']) ? $edit['roles'] : $account->roles;
      $roles += array(DRUPAL_AUTHENTICATED_RID => DRUPAL_AUTHENTICATED_RID);
      $actions_results = db_query("
        SELECT
          actions
        FROM
          {scald_role_actions}
        WHERE
          rid IN (" . implode(', ', array_keys($roles)) . ")
      ");
      while ($actions_raw = db_fetch_array($actions_results)) {
        $edit['scald_actions'] = $edit['scald_actions'] | $actions_raw['actions'];
      }
      break;
    case 'view':
      // @@@TODO: Display Scald Actions abilities to user?  Admin only?
      break;
    default:
      break;
  }
} // end scald_user()

/**
 * Implementation of hook_views_api()
 */
function scald_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'scald') .'/includes/',
  );
}

/**
 * Implementation of hook_flush_caches()
 */
function scald_flush_caches() {
  return array('cache_scald');
}

function theme_scald_render_error($context, $message){
	return '<h3>'.$message.'</h3>';
}
