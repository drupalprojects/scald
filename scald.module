<?php

/**
 * @defgroup scald Scald is Content, Attribution, Licensing, & Distribution
 *
 */

/**
 * @file
 * The Scald Core, which handles all Scald Registries and dispatch.
 *
 * The Scald Core handles the Scald Registries for all the aspects of Scald.
 * The Scald API is also defined here; the majority of a developer's
 * interaction with Scald will be through the Scald API defined herein.  See
 * the docs folder for more detailed information.
 *
 * @ingroup scald
 */

require_once('includes/scald.constants.inc');


/*******************************************************************************
 * SCALD PROVIDERS & CONFIGURATION
 ******************************************************************************/

/**
 * Get the available Scald Unified Types
 *
 * This function determines and returns a structured array specifying all the
 *  currently provided Scald Unified Types.  The Scald Unified Types array has
 *  the following format:
 *  array(
 *    'type-slug' => array(
 *      'title'     => 'Plain-text title',
 *      'providers' => array(
 *        'provider',
 *        ...
 *    ),
 *    ...
 *  );
 *
 * @return
 *   The Scald Unified Types array
 */
function scald_types() {
  $types = db_select('scald_types', 's')
    ->fields('s', array('type', 'title', 'provider'))
    ->execute()
    ->fetchAllAssoc('type');

  return $types;
} // end scald_types()

/**
 * Returns a list of available atom type names.
 *
 * @return array
 *   An array of atom type names, keyed by the type machine name.
 */
function scald_type_get_names() {
  $types = scald_types();
  $options = array();
  foreach ($types as $name => $type) {
    $options[$name] = $type->title;
  }
  return $options;
}

/**
 * Add a Scald unified type
 *
 * This function create a new type if it does not already exist.
 *
 * @return
 *   TRUE if the new type was added, FALSE if already exists.
 */
function scald_add_type($type, $title, $description) {
  // Check if this type already exists
  $types = scald_types();
  if (!empty($types[$type])) {
    return FALSE;
  }

  // Create a new type
  db_insert('scald_types')
    ->fields(array('type', 'title', 'description', 'provider'))
    ->values(array($type, $title, $description, 'scald'))
    ->execute();

  // And add fields on it

  // Instantiante the Scald Thumbnail field.
  $instance = array(
    'field_name' => 'scald_thumbnail',
    'entity_type' => 'scald_atom',
    'bundle' => $type,
    'label' => 'Thumbnail',
    'required' => FALSE,
  );
  if(!field_read_instance($instance['entity_type'], $instance['field_name'], $instance['bundle'])) {
    field_create_instance($instance);
  }

  // Instantiate the Scald Authors field.
  $instance = array(
    'field_name' => 'scald_authors',
    'entity_type' => 'scald_atom',
    'bundle' => $type,
    'label' => 'Authors',
    'required' => FALSE,
    'widget' => array(
      'type' => 'taxonomy_autocomplete',
    ),
  );
  if(!field_read_instance($instance['entity_type'], $instance['field_name'], $instance['bundle'])) {
    field_create_instance($instance);
  }

  // Instantiate the Scald Tags field.
  $instance = array(
    'field_name' => 'scald_tags',
    'entity_type' => 'scald_atom',
    'bundle' => $type,
    'label' => 'Tags',
    'required' => FALSE,
    'widget' => array(
      'type' => 'taxonomy_autocomplete',
    ),
  );
  if(!field_read_instance($instance['entity_type'], $instance['field_name'], $instance['bundle'])) {
    field_create_instance($instance);
  }

  // Flush our caches
  scald_contexts(TRUE);

  return TRUE;
} // end scald_add_type()



/**
 * Get available Scald Contexts
 *
 * This function determines and returns a structured array specifying all the
 *  currently provided Scald Contexts.  The Scald Contexts array is cached in
 *  the Drupal variables table and only rebuilt upon request from this function.
 *  The Scald Contexts array has the following format:
 *  array(
 *    'context-slug' => array(
 *      'provider'        => 'provider-name',
 *      'render_language' => 'language-slug',   // e.g. 'XHTML'
 *      'type_format'         => array(
 *        'type-slug'   => array(
 *          'file_format' => 'format-slug'
 *          'transcoder'  => 'transcoder-slug'
 *        ),
 *        ...
 *      ),
 *    ),
 *    ...
 *  );
 *
 * @return
 *   The Scald Contexts array
 */
function scald_contexts($reset = FALSE) {
  return _scald_get_info('contexts', $reset);
}

/**
 * Implements hook_scald_contexts_alter.
 *
 * Adds informations on the configured transcoder formats to
 * the standard info hook output.
 */
function scald_scald_contexts_alter(&$contexts) {
  $result = db_select('scald_context_type_transcoder', 's')
    ->fields('s')
    ->execute();

  while ($row = $result->fetchAssoc()) {
    $contexts[$row['context']]['type_format'][$row['type']] = $row;
  }
}


/**
 * Get the available Scald Actions
 *
 * This function returns a structured array which specifies all the currently
 *  provided Scald Actions.  The actions are in an array with one or more
 *  elements in the format:
 *  array(
 *    'action-slug' => array(
 *      'provider' => 'provider-name',
 *      'title'    => 'Plain-text title',
 *      'mask'     => 0x04,
 *    ),
 *    ..
 *  );
 *
 * @return
 *  The Scald Actions array.
 */
function scald_actions($reset = FALSE) {
  return _scald_get_info('actions', $reset);
}

/**
 * Implements hook_scald_actions_alter.
 *
 * Assigns each actions an unique bitmask.
 */
function scald_scald_actions_alter(&$actions) {
  $powers = variable_get('scald_actions_powers', array());
  $max_power = empty($powers) ? 0 : (max($powers) + 1);
  $new_power = FALSE;
  foreach ($actions as $name => $action) {
    if (!isset($powers[$name])) {
      $new_power = TRUE;
      $powers[$name] = $max_power++;
    }

    $actions[$name]['bitmask'] = pow(2, $powers[$name]);
  }

  if ($new_power) {
    variable_set('scald_actions_powers', $powers);
  }
}

/**
 * Get the available Scald Transcoders
 *
 * This function returns a structured array which specifies all the currently
 *  provided Scald Transcoders.  The actions are in an array with one or more
 *  elements in the format:
 *  array(
 *    'transcoder-slug' => array(
 *      'provider' => 'provider-name',
 *      'formats'  => array(
 *        'type-slug' => 'file_format',
 *        ...
 *    ),
 *    ...
 *  );
 *
 * @return
 *   The Scald Transcoders array
 */
function scald_transcoders($reset = FALSE) {
  return _scald_get_info('transcoders', $reset);
}

/**
 * Get the list of module that have registered themselves as atom providers.
 *
 * This function returns an associative array with the following formats:
 * array(
 *   'type-slug1' => array(
 *     'module-name1' => 'label1',
 *     'module-name2' => 'label2',
 *   )
 * );
 *
 * @return
 *   The Scald Atom Providers array.
 */
function scald_atom_providers($reset = FALSE) {
  $types = array();
  $hook = 'scald_atom_providers';
  foreach (module_implements($hook) as $module) {
    foreach (module_invoke($module, $hook) as $type => $label) {
      $types[$type][$module] = $label;
    }
  }
  drupal_alter($hook, $types);
  return $types;
}

/**
 * Get the info from all modules on a specific scald item type.
 */
function _scald_get_info($type, $reset = FALSE) {
  $info = cache_get($type, 'cache_scald');
  if ($reset || empty($info)) {
    $info = array();
    $hook = 'scald_' . $type;
    foreach (module_implements($hook) as $module) {
      $list = module_invoke($module, $hook);
      foreach ($list as &$item) {
        $item['provider'] = $module;
      }
      $info = array_merge($info, $list);
    }
    drupal_alter($hook, $info);
    cache_set($type, $info, 'cache_scald');
  }
  else {
    $info = $info->data;
  }
  return $info;
}

/**
 * Get the defaults options for a specific Atom type.
 */
function scald_atom_defaults($type) {
  $all = variable_get('scald_atom_defaults', array());
  if (isset($all[$type])) {
    $default = $all[$type];
  }
  else {
    $types = scald_types();
    $actions = scald_actions();
    $default = new stdClass();
    $default->actions = $actions['view']['bitmask'] + $actions['fetch']['bitmask'];
    $default->description = '';
    $default->thumbnail_source = drupal_get_path('module', 'scald') . '/assets/thumbnail_default.png';
  }
  return $default;
}


/*******************************************************************************
 * SCALD ATOM CRUD
 ******************************************************************************/

/**
 * Load a Scald Atom
 * @param $sid
 *  The Scald ID being loaded.
 * @return
 *   The Scald atom
 *   FALSE upon failure
 */
function scald_atom_load($sid) {
  $atom = scald_atom_load_multiple(array($sid));
  return $atom ? $atom[$sid] : FALSE;
}

/**
 * Load multiple Scald atoms.
 *
 * @todo This function needs to be optimized;
 */
function scald_atom_load_multiple($sids) {
  $atoms = array();
  foreach ($sids as $sid) {
    $atoms[$sid] = scald_fetch($sid);
  }
  return $atoms;
}

/**
 * Save changes to a Scald Atom, or create a new one
 *
 * @param $atom
 *  A Scald Atom Object
 *   At minimum, 'type', 'provider', and 'base_id' (which uniquely identifies a
 *   given Atom) are required.  Additional included values which are keyed by
 *   recognized Scald Atom Object members will be used for those members and
 *   any additional values will be passed along to the Providers.
 * @return
 *   The Scald ID upon successful save
 *   FALSE upon failure
 */
function scald_atom_save(&$atom) {
  // First pass Atom object validation
  $types = scald_types();

  // Verify type
  if (empty($types[$atom->type])) {
    return FALSE;
  }

  // Ensure the Atom Object has all the required members
  if (!isset($atom->publisher)) {
    $atom->publisher = NULL;
  }
  if (!isset($atom->actions)) {
    $atom->actions = NULL;
  }
  if (!isset($atom->title)) {
    $atom->title = '';
  }
  if (!isset($atom->data)) {
    $atom->data = array();
  }

  $op = empty($atom->sid) ? 'insert' : 'update';
  $hook = ($op == 'insert') ? 'scald_register_atom' : 'scald_update_atom';

  // The Type Provider can implement some other defaults at this point, but
  //  the Atom Provider may override them.
  module_invoke($types[$atom->type]->provider, $hook, $atom, 'type');

  // Hand the Atom off to the Atom Provider to do additional processing and
  //  population
  // NOTE: Providers explicitly have access to change the Atom's basic members
  //  to allow for hypothetical "dispatch Providers" which would determine the
  //  appropriate Provider and/or characteristics of an Atom upon registration.
  module_invoke($atom->provider, $hook, $atom, 'atom');


  // Another round of member validation is necessary due to the potential for
  //  the Providers to modify them.  By design!
  if (empty($atom->type) || empty($atom->provider)) {
    return FALSE;
  }

  if (empty($types[$atom->type])) {
    return FALSE;
  }

  // Only supply defaults for the Actions bitstring if the Provider did nothing.
  //  Otherwise assume that the bitstring is intentional.
  if (is_null($atom->actions)) {
    $defaults = scald_atom_defaults($atom->type);
    $atom->actions = $defaults->actions;
  }

  // Do "poor-man's" UID validation.
  if (empty($atom->publisher) || !is_numeric($atom->publisher) || !($atom->publisher > 0)) {
    global $user;
    $atom->publisher = $user->uid;
  }

  field_attach_presave('scald_atom', $atom);

  // Inform all modules before writing the atom in the database
  module_invoke_all('scald_atom_presave', $atom);
  module_invoke_all('entity_presave', $atom, 'scald_atom');

  // Put the basic data in the Scald Atom Registry
  if($op == 'update') {
    $written = drupal_write_record('scald_atoms', $atom, array('sid'));
  }
  else {
    $written = drupal_write_record('scald_atoms', $atom);
  }

  if (!$written) {
    return FALSE;
  }

  $function = 'field_attach_' . $op;
  $function('scald_atom', $atom);

  // Notify all modules of our new atom.
  module_invoke_all('scald_atom_' . $op, $atom);
  module_invoke_all('entity_' . $op, $atom, 'scald_atom');

  // Transcoding
  // Only fire hook_register_atom() for Transcoder Providers that might be
  //  responsible for transcoding this Atom (based on the currently-configured
  //  Context and Transcoder settings).

  $contexts = scald_contexts();
  $transcoders = scald_transcoders();

  foreach ($contexts as $context => $details) {
    if (isset($details['type_format'][$atom->type])) {
      $transcoder = $details['type_format'][$atom->type]['transcoder'];
      $values['@ccontext'] = $context;
      module_invoke($transcoders[$transcoder]['provider'], $hook, $atom, 'transcoder');
    }
  }

  // Clear the render cache
  cache_clear_all($atom->sid . ':', 'cache_scald', TRUE);

  // Clear the static caches
  entity_get_controller('scald_atom')->resetCache(array($atom->sid));

  return $atom->sid;
} // end scald_atom_save()

/**
 * Delete a Scald atom.
 *
 * @param int $sid Scald atom ID.
 */
function scald_atom_delete($sid) {
  scald_atom_delete_multiple(array($sid));
}

/**
 * Delete multiple Scald atoms.
 *
 * @param array $sids An array of Scald atom IDs.
 */
function scald_atom_delete_multiple($sids) {
  $atoms = scald_atom_load_multiple($sids);
  if ($atoms) {
    $transaction = db_transaction();
    // Delete the Scald atoms.
    db_delete('scald_atoms')
      ->condition('sid', array_keys($atoms), 'IN')
      ->execute();
    try {
      foreach ($sids as $sid) {
        $atom = scald_atom_load($sid);
        field_attach_delete('scald_atom', $atom);
        module_invoke_all('scald_atom_delete', $atom);
        module_invoke_all('entity_delete', $atom, 'scald_atom');
      }
    }
    catch (Exception $e) {
      $transaction->rollback();
      watchdog_exception('scald_atom', $e);
      throw $e;
    }
  }
}

/**
 * Unregister a Scald Atom
 *
 * @param $sid
 *  The Scald ID of the Atom being unregistered *OR* the Atom object.
 * @return boolean
 *  TRUE is the atom was successfully unregistered, FALSE otherwise
 */
function scald_unregister_atom($sid) {
  if (is_object($sid)) {
    $sid = $sid->sid;
  }

  // If we couldn't get back to the atom id  at this point, we won't be able to
  // unregister the atom, so let's just abort.
  if (!is_numeric($sid)) {
    return FALSE;
  }

  // Force a rebuild to ensure that the most-current instance is being used as
  //  when informing Providers of the impending destruction.
  $atom = scald_fetch($sid, TRUE);

  // If we couldn't fetch the object, abort early too, the atom has already been
  // unregistered.
  if (!is_object($atom)) {
    return FALSE;
  }

  $types = scald_types();
  $transcoders = scald_transcoders();

  // Revoke all permissions on the Atom, making it inaccessible.
  db_update('scald_atoms')
    ->fields(array('actions', 0))
    ->condition('sid', $sid)
    ->execute();

  // Alert the Providers that this Atom is gone
  module_invoke($types[$atom->type]['provider'], 'scald_unregister_atom', $atom, 'type');
  module_invoke($atom->provider, 'scald_unregister_atom', $atom, 'atom');

  foreach (scald_contexts() as $context => $details) {
    if (isset($details['type_format'][$atom->type]) && $transcoder = $details['type_format'][$atom->type]['transcoder']) {
      module_invoke($transcoders[$transcoder]['provider'], 'scald_unregister_atom', $atom, 'transcoder');
    }
  }

  // Clear the memory cache
  scald_is_registered($sid, TRUE);
  // Clear the render cache
  cache_clear_all($sid . ':', 'cache_scald', TRUE);
} // end scald_unregister_atom()



/**
 * Determine if a Scald Atom is registered with Scald Core or not.
 *
 * @param $sid
 *   The Scald ID being tested.
 * @return
 *   A Scald Atom Object if the Scald ID is valid.  The Atom Object is *ONLY*
 *    populated with the following members: type, provider, base_id, actions,
 *    and fetched *set to FALSE*.
 *   FALSE if $sid is not a valid Scald ID (int) or if it does not reference an
 *    Atom.
 */
function scald_is_registered($sid, $rebuild = FALSE) {
  // Argument validation
  if (!is_numeric($sid)) {
    return FALSE;
  }
  $sid = (int) $sid;

  static $scald_atoms;
  if (!isset($scald_atoms)) {
    $scald_atoms = array();
  }

  // Reference the memory cache when appropriate
  if (!$rebuild && isset($scald_atoms[$sid])) {
    return $scald_atoms[$sid];
  }

  // Build the Atom from the db
  $registration_results = db_query("SELECT * FROM {scald_atoms} WHERE sid = :sid", array(':sid' => $sid));
  if (!$registration_results) {
    // Ensure that no Atoms linger improperly post-deletion
    unset($scald_atoms[$sid]);
    return FALSE;
  }
  $atom = $registration_results->fetchObject();

  if (!empty($atom)) {
    $atom->fetched = FALSE;
  }
  else {
    return FALSE;
  }

  $scald_atoms[$sid] = $atom;

  return $scald_atoms[$sid];
} // end scald_is_registered()



/**
 * Load a Scald Atom.
 *
 * @param $sid
 *   The Scald ID of the Atom to load.
 * @param $rebuild
 *   If set to TRUE, the Atom will be reloaded from the DB even if it is already
 *    present in the memory cache.
 * @return
 *   A populated Scald Atom object
 *   FALSE if SID is invalid or if $user is not permitted to fetch the Scald Atom
 */
function scald_fetch($sid, $rebuild = FALSE) {
  // Verify the SID is legit and fetch basic info about the Atom
  $atoms = entity_load('scald_atom', array($sid), array(), $rebuild);
  if (!$atoms) {
    return FALSE;
  }

  $atom = reset($atoms);

  // Verify that the current user is allowed to fetch this Atom
  if (!scald_action_permitted($atom, 'fetch')) {
    return FALSE;
  }

  // Check the memory cache for the Atom
  static $scald_atoms;
  if (empty($scald_atoms)) {
    $scald_atoms = array();
  }

  if (!$rebuild && isset($scald_atoms[$sid])) {
    return $scald_atoms[$sid];
  }


  // Let the Atom Type Provider handle any defaults
  $types = scald_types();

  module_invoke($types[$atom->type]->provider, 'scald_fetch', $atom, 'type');

  $atom->base_entity = NULL;

  module_invoke($atom->provider, 'scald_fetch', $atom, 'atom');

  // If the Providers tried to mess with "protected" Atom object members, fail!
  if ($sid != $atom->sid) {
    return FALSE;
  }

  // Ensure all required Atom members are populated with at minimum default
  //  values.  NOTE: it is assumed that Atom Providers won't be monkeying with
  //  the "essentials" like the Type, Provider, SID, etc.
  $defaults = scald_atom_defaults($atom->type);
  if (empty($atom->file_source)) {
    $atom->file_source = $defaults->file_source;
  }
  if (empty($atom->thumbnail_source)) {
    $atom->thumbnail_source = $defaults->thumbnail_source;
  }
  if (empty($atom->description)) {
    $atom->description = $defaults->description;
  }

  $atom->fetched = TRUE;
  $scald_atoms[$sid] = $atom;

  return $atom;
} // end scald_fetch()



/**
 * Determine if a Scald Atom is fetched
 *
 * @param $atom
 *   The Scald Atom to test
 * @return
 *   TRUE/FALSE
 */
function scald_is_fetched($atom = NULL) {
  return (
    is_object($atom)
    && isset($atom->fetched)
    && $atom->fetched
  );
} // end scald_is_fetched()



/**
 * Find Atoms matching a given set of characteristics.
 *
 * @param $query
 *  A keyed array with one or more of the following keys:
 *    'provider'
 *    'type'
 *    'base_id'
 *    'publisher'
 *    'actions'
 *    'title'
 * @param $fuzzy
 *  A boolean that if set to TRUE broadens the search to include partial matches
 *  on all parameters
 * @param $singular
 *  A boolean that if set to TRUE ensures that only one result is returned.  The
 *   return value is a single SID (scalar, not in an array).
 * @return
 *  An array of SIDs that match the characteristics specified
 *  FALSE on bad input or no results
 */
function scald_search($query = array(), $fuzzy = FALSE, $singular = FALSE) {
  // Argument validation
  if (empty($query) || !is_array($query)) {
    return FALSE;
  }

  $types = scald_types();
  $providers = scald_atom_providers();

  if (!$fuzzy && !empty($query['type']) && !is_array($query['type']) && !in_array($query['type'], array_keys($types))) {
    unset($query['type']);
  }

  if (!empty($query['providers']) && !in_array($query['provider'], $providers)) {
    unset($query['provider']);
  }


  // Build the query & execute
  $wheres = array();
  $data = array();
  foreach ($query as $field => $value) {
    switch ($field) {
      case 'title':
      case 'type':
      case 'base_id':
      case 'provider':
        if (is_array($value)) {
          $condition = db_placeholders($value, 'text');
          $wheres[] = $field . " IN($condition)";
          $data = array_merge($data, $value);
        }
        else {
          $placeholder = ":" . $field;
          if ($fuzzy) {
            $wheres[] = $field ." LIKE '%%" . $placeholder . "%%'";
          }
          else {
            $wheres[] = $field ." = " . $placeholder;
          }
          $data[$placeholder] = $value;
        }
        break; // end 'title/type/base_id/provider'

      case 'publisher':
        $placeholder = ":" . $field;
        $wheres[] = $field . " = " . $placeholder;
        $data[$placeholder] = $value;
        break; // end 'publisher'

      case 'actions':
        break; // end 'actions'

      default:
        continue;
    }
  }

  // @@@TODO: Use a pager_query() call here?
  $search_results = db_query(
    "
      SELECT
        sid
      FROM
        {scald_atoms}
      WHERE "
      . implode(' AND ', $wheres)
      . ($singular ? " LIMIT 1" : '')
    , $data
  );

  // Compose and return result
  $sids = array();
  foreach($search_results as $result) {
    $sids[] = $result->sid;
  }

  if(!count($sids)) {
    return FALSE;
  }

  if($singular) {
    return $sids[0];
  }
  else {
    return $sids;
  }

} // end scald_search()

/*******************************************************************************
 * SCALD CONVERSION UTILITIES
 ******************************************************************************/

/**
 * Process a text string and replace Scald Atom Shorthand (SAS) with rendered
 *  Scald Atoms.
 *
 * Looks for strings along the lines of [scald=SID:context-slug options].
 *
 * @see scald_rendered_to_sas
 *
 * @param $string
 *   A text string to be processed.
 * @param $context
 *   A Scald Context.  If $override is FALSE, this Context will only be used to
 *    render the included Scald Atoms if the SAS does not specify a valid Scald
 *    Context.  Defaults to 'title', which is a Scald Context provided by Scald
 *    Core and therefore guaranteed to be registered.
 * @param $override
 *   A boolean used to determine if the Scald Context specified in the SAS
 *    should be used or not.
 * @return
 *   The same text string, but with
 */
function scald_sas_to_rendered($string, $context = NULL, $override = FALSE) {
  if (empty($context)) {
    $context = 'title';
  }

  global $_scald_override;
  $_scald_override = $override;
  $rendered = preg_replace_callback(
    SCALD_SAS_MATCH_PATTERN,
    create_function(
      '$matches',
      '
        global $_scald_override;
        return scald_render(
          $matches[1],
          (!empty($matches[2]) && !$_scald_override ? $matches[2] : \'' . $context . '\'),
          (!empty($matches[3]) ? $matches[3] : NULL)
        );
      '
    ),
    $string
  );

  unset($_scald_override);
  return $rendered;
} // end scald_sas_to_rendered()



/**
 * Determine atoms (expressed as SAS) embedded in a string.
 *
 * @param $string
 *  The string to search for SAS
 * @return
 *  An array of SIDs which are included in the string in SAS form.
 */
function scald_included($string) {
  $matches = array();
  if (!preg_match_all(
    SCALD_SAS_MATCH_PATTERN,
    $string,
    $matches
  )) {
    return array();
  }

  return $matches[1];
} // end scald_included()



/**
 * Process a text string and replace rendered Scald Atoms with Scald Atom
 *  Shorthand (SAS).
 *
 * @see scald_sas_to_rendered
 *
 * NOTE: Scald Core only contains an implementation for parsing Scald Atoms
 *  rendered in XHTML.  Additional implementations can be supplied by
 *  implementing hook_scald_rendered_to_sas_RENDER_LANGUAGE()
 *
 * NOTE: The Scald Core implementation of parsing for XHTML *assumes* that the
 *  standard Scald classes are attached to the outermost (containing) HTML
 *  element.  If a Scald Context does not produce output matching this format
 *  then this function will fail to detect and replace the Scald Atoms rendered
 *  by that Context.  See docs/scald_overview.txt and
 *  docs/scald_provider_api.txt for additional details.  Also see the Context
 *  section in the Scald Administration pages for a tool to detect which Scald
 *  Contexts will not produce output which can be parsed by this function.
 *
 * @param $string
 *   A text string to be processed.
 * @param $render_language
 *   The expected format of $text.  Should correspond to the render_language
 *    specified by Scald Contexts.  Defaults to XHTML.
 * @return
 *  The source string with all rendered Scald Atoms replaced with Scald Atom
 *   Shorthand (SAS).
 */
function scald_rendered_to_sas($string, $render_language = 'XHTML') {
  // If Scald Core can't handle it, maybe a Scald Provider can.
  // NOTE: This will probably fail if more than one Scald Provider implements
  //        support for the same render language.
  if ($render_language != 'XHTML') {
    $strings = module_invoke_all('scald_rendered_to_sas_' . $render_language, $string);
    return $strings[0];
  }

  return preg_replace_callback(
    SCALD_RENDERED_MATCH_PATTERN,
    create_function(
      '$matches',
      '
        return \'[scald=\' . $matches[1] . (!empty($matches[2]) ? \':\' . $matches[2] : \'\') . (!empty($matches[3]) ? \' \' . $matches[3] : \'\') . \']\';
      '
    ),
    $string
  );
} // end scald_rendered_to_sas()






/*******************************************************************************
 * SCALD ACTIONS & LICENSES
 ******************************************************************************/

/**
 * Determine the Scald Actions Bitstring for a given Atom for a given User.
 *
 * @param $atom
 *   A Scald Atom
 * @param $account
 *   A Drupal user account
 *   Defaults to the current $user
 * @return
 *   A Scald Actions Bitstring
 *   FALSE if the Atom is invalid
 */
function scald_user_actions($atom, $account = NULL) {

  // Argument validation
  if (is_null($account)) {
  	global $user;
    $account = $user;
  }

  // Combine the account scald_actions if they do not exists
  // May happen to UID = 1 which does not go through hook_user_load()
  if (!isset($account->scald_actions)) {
    $account->scald_actions = _scald_user_combine_actions($account);
  }

  // NOTE: Not using scald_is_fetched here because Action validation can (and
  //  should) be done prior to fetching.  However, it is assumed that this $atom
  //  is *at least* the result of a scald_is_registered() call.
  if (!is_object($atom) || !isset($atom->actions)) {
    return FALSE;
  }

  // The Account in question belongs to the Scald Publisher of this Atom
  $actions_key = ($atom->publisher == $account->uid) ? 'own' : 'any';

  // Check for the "bypass atom access restrictions" permission for this user
  //  if it is set, OR the  "Atom" and the "User Action" rather than ANDing them.
  return user_access('bypass atom access restrictions') 
    ? ($atom->actions | $account->scald_actions[$actions_key]) 
    : ($atom->actions & $account->scald_actions[$actions_key]);
} // end scald_actions()



/**
 * Determines if a given User can act on a given Atom in a given way.
 *
 * @@@TODO: Implement an optional batch mode which takes an array of Scald
 *          Actions.
 *
 * @param $atom
 *   A Scald Atom
 * @param $action
 *   A Scald Action slug
 * @param $account
 *   A Drupal user account
 *   Defaults to the current $user
 * @return
 *   TRUE/FALSE
 */
function scald_action_permitted($atom, $action = 'fetch', $account = NULL) {
  $actions = scald_actions();
  if (empty($actions[$action])) {
    return FALSE;
  }

  return (bool) (scald_user_actions($atom, $account) & $actions[$action]['bitmask']);
} // end scald_action_permitted()



/**
 * Implementation of hook_user_load().
 */
function scald_user_load($users) {
  // For each loaded user get combined scald_actions
  foreach($users as $uid => $account) {
    $account->scald_actions = _scald_user_combine_actions($account);
  }
} // end scald_user_load()


/**
 * Implementation of hook_user_load().
 * Fetch action bitstring components by User Role and combine
 */
function _scald_user_combine_actions($account) {
  $scald_actions = array(
    'own' => 0,
    'any' => 0,
  );

  // Fetch action bitstring components by User Role and combine
  foreach($account->roles as $rid => $role_name) {
    $cache = cache_get('scald_actions_bitstring_for_rid_' . $rid, 'cache_scald');
    if(empty($cache)) {
      // cache miss
      $role_actions = scald_compute_role_actions(array($rid => $role_name));      
    }
    else {
      $role_actions = $cache->data;
    }

    $scald_actions['own'] |= $role_actions['own'];
    $scald_actions['any'] |= $role_actions['any'];
  }

  // Allow operations that are allowed on any atoms to
  // the user own atoms too.
  $scald_actions['own'] |= $scald_actions['any'];

  return $scald_actions;
}




/*******************************************************************************
 * SCALD CONTEXTS AND RENDERING
 ******************************************************************************/

/**
 * Prepare a Scald Atom for rendering
 *
 */
function scald_prerender(&$atom, $context, $options = NULL) {
  $types = scald_types();
  $contexts = scald_contexts();
  $transcoders = scald_transcoders();
  $actions = scald_actions();
  $context_config = $contexts[$context];

  // Build the portion of the Rendered member which Providers are expected to
  //  manipulate.
  $atom->rendered = new stdClass;
  $atom->rendered->sid = $atom->sid;
  $atom->rendered->title = $atom->title;
  $atom->rendered->file_source_url = empty($atom->file_source) ? NULL : url($atom->file_source);
  $atom->rendered->file_transcoded_url = NULL;
  $atom->rendered->thumbnail_source_url = file_create_url($atom->thumbnail_source);
  $atom->rendered->description = $atom->description;
  $atom->rendered->nocache = FALSE;

  // Type & Atom prerenders
  module_invoke($types[$atom->type]->provider, 'scald_prerender', $atom, $context, $options, 'type');
  module_invoke($atom->provider, 'scald_prerender', $atom, $context, $options, 'atom');

  // Transcoder Provider prerender -- only if there is a Transcoder specified
  //  for this Context.
  //  POPULATES: $atom->rendered->file_transcoded_url
  if (!empty($context_config['type_format']) && !empty($context_config['type_format'][$atom->type])) {
    module_invoke($transcoders[$context_config['type_format'][$atom->type]['transcoder']]['provider'], 'scald_prerender', $atom, $context, $options, 'transcoder');
  }

  // Context prerender
  module_invoke($context_config['provider'], 'scald_prerender', $atom, $context, $options, 'context');

  // Populate default rendered members & validate other rendered members.
  $atom->rendered->title = check_plain($atom->rendered->title);
  $atom->rendered->description = filter_xss($atom->rendered->description);
  $atom->rendered->type = check_plain($types[$atom->type]->title);

  // Actions
  $atom->rendered->actions = scald_atom_user_build_actions_links($atom);

  // Authors
  $atom->rendered->authors = array();
  $items = field_get_items('scald_atom', $atom, 'scald_authors');
  if (!empty($items)) {
    foreach ($items as $delta => $term) {
      $tids[$delta] = $term['tid'];
    }
    $authors = taxonomy_term_load_multiple($tids);
    foreach ($authors as $author) {
      $url = field_get_items('taxonomy_term', $author, 'scald_author_url');
      if (!empty($url)) {
        $author->link = l($author->name, $url[0]['value']);
      }
      else {
        $author->link = check_plain($author->name);
      }
      $atom->rendered->authors[] = $author;
    }
  }

  // User
  // NOTE: This query is much faster than a user_load() (no JOIN)
  $name = db_select('users', 'u')
    ->fields('u', array('name'))
    ->condition('u.uid', $atom->publisher)
    ->execute()
    ->fetchField();

  $atom->rendered->publisher = array(
    'uid'  => $atom->publisher,
    'name' => $name,
    'path' => 'user/' . $atom->publisher,
    'link' => l($name, 'user/' . $atom->publisher),
  );

} // end scald_prerender()



/**
 * Render a Scald Atom
 *
 * "Rendering" takes an Atom and generates output (typically XHTML) based on the
 *  "Context" which is specified.  The Context is essentially a template.
 *
 * NOTE: scald_render() gets called recursively until a viable output is
 *  generated.  It may return FALSE on a given call, but it will ultimately fall
 *  back to the 'title' Context which is provided by Scald Core and *always*
 *  generates *something*.  Even if a
 *
 * @param $sid
 *   A Scald ID *OR* a Scald Atom.
 * @param $context
 *   A valid Scald Context slug (a text string)
 * @param $options
 *   An optional text string specifying additional Scald Context-specific
 *    options that get passed to the Scald Context for rendering (e.g. a
 *    mechanism for specifying the size of an image).
 * @param $rebuild
 *   Set to true to force a rebuild of the rendering.
 * @return
 *   The rendered Scald Atom (usually an XHTML string ready for display)
 *   FALSE if the rendering failed for whatever reason
 */
function scald_render($sid, $context, $options = NULL, $rebuild = FALSE) {
  // Argument validation
  if (!is_numeric($sid)) {
    if (!empty($sid->sid)) {
      $atom = $sid;
      $sid  = $atom->sid;
    }
    else {
      return FALSE;
    }
  }

  // Load the Atom Object in order to use it for determining the current Actions
  //  bitstring and for recursive scald_render() calls.
  $atom_reg = scald_is_registered($sid, $rebuild);
  if (empty($atom)) {
    $atom = $atom_reg;
  }

  // SID doesn't correspond to a registered Atom; drop through to render the
  //  "Invalid ID" message.
  if (empty($atom_reg)) {
    return scald_scald_render($atom_reg, 'invalid-id');
  }

  // Drop through to no-access rendering if current user can't view.
  if (!scald_action_permitted($atom, 'view')) {
    return scald_scald_render($atom, 'no-access');
  }

  $contexts = scald_contexts();

  // In the event of an invalid Context, initiate fallbacks.  Immediate return
  //  avoids caching a different rendering as the specified Context.
  if (empty($contexts[$context])) {
    return scald_render($atom, _scald_context_fallback($type, $context), $options, $rebuild);
  }

  // Check the cache unless explicitly rebuilding the rendering of the Atom
  $cache_id = $sid
	    . ':' . $context
	    . ':' . scald_user_actions($atom)
	    . (is_null($options) ? '' : ':' . $options);
  if (!$rebuild && !variable_get('scald_always_rebuild', FALSE)) {
    $cache = cache_get($cache_id, 'cache_scald');
    if (!empty($cache)) {
      return $cache->data;
    }
  }


  // Either a cache miss or an explicit rebuild.  Pull in the rest of the Atom.
  if (!scald_is_fetched($atom)) {
    $atom = scald_fetch($sid);
  }

  scald_prerender($atom, $context, $options);

  // Context Provider does the final rendering
  $rendered = module_invoke($contexts[$context]['provider'], 'scald_render', $atom, $context, $options);

  // The Context exists but rendering is failing hard for some reason.  Output
  //  still needs to be ensured, however.  Also note that an empty string is
  //  valid output.  However, hook_scald_render() should return FALSE upon
  //  failure and module_invoke() will return NULL if the function does not
  //  exist.
  if ($rendered === FALSE || is_null($rendered)) {
    return scald_render($atom, _scald_context_fallback($atom->type, $context), $options, $rebuild);
  }

  // For so-called "parsable" Contexts, ensure a standard format for the
  //  enclosing comments.
  if ($contexts[$context]['parseable']) {
    $rendered = '<!-- scald=' . $atom->sid . ':' . $context . (!empty($options) ? ' ' . $options : '') . ' -->' . $rendered . '<!-- END scald=' . $atom->sid . ' -->';
  }

  // Only cache the Atom if Contexts, etc. have not indicated that the rendering
  //  is not cacheable (e.g. it contains the current user's username).
  if (!$atom->rendered->nocache) {
    // Note that cached renderings of an Atom will stick around until
    //  scald_update_atom() is called on the Atom.  This is usually the
    //  responsibility of the Atom Provider as it has the best idea when the base
    //  entity is changing.
    cache_set($cache_id, $rendered, 'cache_scald', CACHE_PERMANENT);
  }

  return $rendered;
} // end scald_render()

/**
 * Render multiple atoms.
 *
 * @param array $atoms
 *   An array of Scald Atoms
 * @param string $context
 *   A valid Scald Context slug (machine name)
 *
 * @return array
 *   A renderable array containing the representations of
 *   the atoms in the choosen context.
 */
function scald_render_multiple($atoms, $context) {
  $output = array();
  foreach ($atoms as $atom) {
    $output[] = array(
      '#markup' => scald_render($atom, $context)
    );
  }
  return $output;
}

/**
 * Determine the next Context in the Context fallback order for this Scald
 *  Scald Unified Type.
 *
 * @param $type
 *   A Scald Unified Type slug
 * @param $context
 *   The Scald Context which is being fallen back from.
 * @return
 *   The next Scald Context in the fallback order
 */
function _scald_context_fallback($type, $context) {
  $contexts = scald_contexts();
  $render_language = !empty($contexts[$context]) ? $contexts[$context]['render_language'] : 'XHTML';
  $scald_context_fallbacks = variable_get('scald_context_fallbacks', 0);

  // Generate a flat array of in-order fallback Contexts.  The highest-index
  //  Context is the most generic and least likely to fail.
  $fallbacks = array_merge(
    !empty($scald_context_fallbacks[$render_language][$type]) ? $scald_context_fallbacks[$render_language][$type] : array(),
    !empty($scald_context_fallbacks[$render_language]['@default']) ? $scald_context_fallbacks[$render_language]['@default'] : array(),
    $scald_context_fallbacks['@default'],
    array('title')  // Included to *ENSURE* that recursion terminates
  );

  // Determine where in the order the current Context falls so that "next" has a
  //  definitive meaning.
  $current_index = array_search($context, $fallbacks);
  if (!$current_index) {
    $current_index = -1;
  }

  return $fallbacks[$current_index+1];
} // end _scald_context_fallback()






/*******************************************************************************
 * SCALD HOOK IMPLEMENTATIONS
 ******************************************************************************/

/**
 * Implements hook_scald_contexts.
 */
function scald_scald_contexts() {
  return array(
    'debug' => array(
      'title'           => t('Debuging Display'),
      'description'     => t('A useful debugging display of a Scald Atom.'),
      'render_language' => 'XHTML',
      'parseable'       => FALSE,
      'hidden'          => TRUE,
      'formats'         => array(
        '<all>' => 'passthrough',
      ),
    ),
    'no-access' => array(
      'title'           => t('No Access'),
      'description'     => t('Built-in Context used when an Atom cannot be viewed by the current User.'),
      'render_language' => 'XHTML',
      'parseable'       => TRUE,
      'hidden'          => TRUE,
      'formats'         => array(),
    ),
    'invalid-id' => array(
      'title'           => t('Invalid ID'),
      'description'     => t('Built-in Context used when an Invalid Scald ID is provided to the rendering stack.'),
      'render_language' => 'XHTML',
      'parseable'       => TRUE,
      'hidden'          => TRUE,
      'formats'         => array(),
    ),
    'deleted'   => array(
      'title'           => t('Deleted'),
      'description'     => t('Built-in Context used when an Atom is no longer present in the Registry (but once was).'),
      'render_language' => 'XHTML',
      'parseable'       => TRUE,
      'hidden'          => TRUE,
      'formats'         => array(),
    ),
    'title'     => array(
      'title'           => t('Title'),
      'description'     => t('Literally *just* the title as plain text, though the language is specified as XHTML for simplicity.'),
      'render_language' => 'XHTML',
      'parseable'       => FALSE,
      'formats'         => array(),
    ),
    'full'      => array(
      'title'           => t('Full page'),
      'description'     => t('Built-in Context used when pre-viewing an atom.'),
      'render_language' => 'XHTML',
      'parseable'       => FALSE,
      'formats'         => array(),
    ),
  );
}

/**
 * Implements hook_scald_transcoders.
 */
function scald_scald_transcoders() {
  return array(
    'passthrough' => array(
      'title'       => t('Passthrough'),
      'description' => t('<see scald.admin.inc>'),
      'formats'     => array(
        'type-a' => 'passthrough',
        'type-b' => 'passthrough',
        // All currently-registered Scald Unified Types would be listed
      ),
    ),
  );
}

/**
 * Implements hook_scald_actions.
 */
function scald_scald_actions() {
  return array(
    'fetch' => array(
      'title'       => t('Fetch'),
      'adjective'   => t('Fetchable'),
      'description' => t('<see scald.admin.inc>'),
    ),
    'edit' => array(
      'title'       => t('Edit'),
      'adjective'   => t('Editable'),
      'description' => t('Edit the details of a Scald Atom'),
    ),
    'view' => array(
      'title'       => t('View'),
      'adjective'   => t('Viewable'),
      'description' => t('View a Scald Atom on-site'),
    ),
    'delete' => array(
      'title'       => t('Delete'),
      'adjective'   => t('Deletable'),
      'description' => t('Delete (unregister) a Scald Atom'),
    ),
  );
}

/**
 * Implementation of hook_scald_prerender().
 *
 * Scald Core implements this hook for its role as a Scald Atom Provider of
 *  Atoms of Scald Unified Type 'composite', for its role as a Scald Context
 *  Provider of Scald Contexts 'debug', 'no-access', 'invalid-id', 'deleted',
 *  'title', and for its role as a Scald Transcoder Provider of Scald Transcoder
 *  'passthrough'.
 *
 * @param $atom
 *  The Scald Atom object to prepare for rendering.
 * @param $mode
 *  A string indicating which mode the prerender function is being called in (
 *   'type', 'atom', 'context', or 'transcoder').
 * @param $context
 *  The Scald Context slug.  Must be optional since Scald Core implements
 *   multiple Providers which require hook_scald_prerender().
 * @param $options
 *  A string which represents any Context options.  Must be optional since Scald
 *   Core implements multiple Providers which require hook_scald_prerender().
 * @return
 *  None; $atom->rendered should be adjusted as appropriate
 */
function scald_scald_prerender($atom, $mode, $context = NULL, $options = NULL) {
  switch ($mode) {
    case 'type':
      break; // end 'type'

    case 'context':
      switch ($context) {
        case 'debug':
          break;

        case 'no-access':
          break;

        case 'invalid-id':
          break;

        case 'deleted':
          break;

        case 'title':
          break;
      }
      break; // end 'context'

    case 'transcoder':
      $atom->rendered->file_transcoded_url = url($atom->file_source);
      break; // end 'transcoder'
  }
} // end scald_scald_prerender()



/**
 * Implementation of hook_scald_render().
 */
function scald_scald_render($atom, $context, $options = NULL) {
  switch ($context) {
    case 'debug':
      return '<pre class="debug">' . print_r($atom, TRUE) . '</pre>';
      break;

    case 'no-access':
      return theme('scald_render_error', $context, t('You do not have access to view this Atom.'));
      break;

    case 'invalid-id':
      return theme('scald_render_error', $context, t('Invalid Scald ID.'));
      break;

    case 'deleted':
      return theme('scald_render_error', $context, t('Atom deleted!'));
      break;

    case 'title':
    default:
      return $atom->rendered->title;
      break;
  }
} // end scald_scald_render()



/**
 * Implementation of hook_scald_action().
 */
function scald_scald_action($atom, $action) {
  switch($action) {
    case 'fetch':
      // No specific functionality necessary here
      break;
    case 'edit':
      // @@@TODO: Implement this as a per-atom-provider kind of thing if possible.
      break;
    case 'view':
      // @@@TODO: Implement as a scald_render() call?
      break;
    case 'delete':
      // @@@TODO: Implement a lightweight confirmation interface and then scald_unregister_atom()
      break;
  }
} // end scald_scald_action()

/*******************************************************************************
 * DRUPAL HOOK IMPLEMENTATIONS
 ******************************************************************************/

/**
 * Implements hook_entity_info.
 *
 * Define a new entity type for the Atoms.
 */
function scald_entity_info() {
  $return = array(
    'scald_atom' => array(
      'label' => t('Atoms'),
      'controller class' => 'ScaldAtomController',
      'base table' => 'scald_atoms',
      'uri callback' => 'scald_atom_uri',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'sid',
        'bundle' => 'type',
        'label' => 'title',
      ),
      'bundle keys' => array(
        'bundle' => 'type'
      ),
      'bundles' => array(),
      'view modes' => array(),
      'view callback' => 'scald_render_multiple',
    )
  );

  $contexts = scald_contexts();
  foreach ($contexts as $slug => $context) {
    $return['scald_atom']['view modes'][$slug] = array(
      'label' => $context['title'],
      'custom settings' => FALSE,
    );
  }

  $types = scald_types();
  foreach ($types as $type => $info) {
    $return['scald_atom']['bundles'][$type] = array(
      'label' => $info->title,
      'admin' => array(
        'path' => 'admin/structure/scald/%scald_type',
        'bundle argument' => 3,
        'real path' => 'admin/structure/scald/' . $type,
        'access arguments' => array('administer content types')
      )
    );
  }

  return $return;
}

/**
 * Implements hook_entity_property_info.
 */
function scald_entity_property_info() {
  $info = array();
  // Add meta-data about the basic node properties.
  $properties = &$info['scald_atom']['properties'];

  $properties['sid'] = array(
    'label' => t("Scald ID"),
    'type' => 'integer',
    'description' => t("The unique ID of the node."),
    'schema field' => 'nid',
  );
  $properties['type'] = array(
    'label' => t("Atom type"),
    'type' => 'token',
    'description' => t("The type of the atom."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer scald atoms',
    'options list' => 'scald_type_get_names',
    'required' => TRUE,
    'schema field' => 'type',
  );
  $properties['title'] = array(
    'label' => t("Title"),
    'description' => t("The title of the atom."),
    'setter callback' => 'entity_property_verbatim_set',
    'schema field' => 'title',
    'required' => TRUE,
  );
  $properties['url'] = array(
    'label' => t("URL"),
    'description' => t("The URL of the atom."),
    'getter callback' => 'entity_metadata_entity_get_properties',
    'type' => 'uri',
    'computed' => TRUE,
  );
  $properties['actions'] = array(
    'label' => t("Status"),
    'description' => t("The actions that are allowed for this atom."),
    'type' => 'integer',
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer scald atoms',
    'schema field' => 'status',
  );
  $properties['publisher'] = array(
    'label' => t("Publisher"),
    'type' => 'user',
    'description' => t("The user who published this atom."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer scald atoms',
    'required' => TRUE,
    'schema field' => 'publisher',
  );
  return $info;
}

/**
 * Implements hook_field_extra_fields.
 */
function scald_field_extra_fields () {
  $extra = array();
  foreach (scald_types() as $slug => $type) {
    $extra['scald_atom'][$slug] = array(
      'form' => array(
        'title' => array(
          'label' => t('Title'),
          'description' => t('Atom title - Scald module element'),
          'weight' => -5,
        )
      )
    );
  }
  return $extra;
}


/**
 * Implements hook_permission().
 *
 * Actions are assigned to Drupal User Roles there.
 */
function scald_permission() {
  $permissions = array(
    'administer scald' => array(
      'title' => t('Administer Scald'),
      'description' => t('Access Atom fields configuration and permissions'),
      'restrict access' => TRUE,
    ),
    'administer scald atoms' => array(
      'title' => t('Administer Scald Atoms'),
      'restrict access' => TRUE,
    ),
    'bypass atom access restrictions' => array(
      'title' => t('Bypass atom access restrictions'),
      'description' => t('Grants access to all atoms.'),
      'restrict access' => TRUE,
    ),
    'create atom of any type' => array(
      'title' => t('Create atom of any type'),
    ),
  );

  // "Create" action for each types
  foreach(scald_types() as $type) {
    $permissions['create atom of ' . $type->type . ' type'] = array(
      'title' => t('Create atom of %type type', array('%type' => $type->type)),
    );
  }

  // Other actions (Fetch, Edit, View, Delete, ....))
  foreach (scald_actions() as $key => $action) {
    $permissions[$key . ' own atom'] = array(
      'title' => t('%action own atom', array('%action' => $action['title'])),
    );

    $permissions[$key . ' any atom'] = array(
      'title' => t('%action any atom marked as %actionable', array('%action' => $action['title'], '%actionable' => $action['adjective'])),
    );
  }

  return $permissions;
}

/**
 * Implementation of hook_menu().
 */
function scald_menu() {
  $items = array();

  $items['scald/debug/%'] = array(
    'title'            => 'Scald Debugging Console',
    'page callback'    => 'scald_debug_console',
    'page arguments'   => array(2),
    'access callback'  => 'user_access',
    'access arguments' => array('administer scald'),
    'file'             => 'includes/scald.debug.inc',
    'type'             => MENU_NORMAL_ITEM,
  );

  $items['admin/content/atoms'] = array(
    'title'             => 'Atoms',
    'weight'            => -60,
    'page callback'     => 'scald_admin_atoms',
    'access callback'   => 'user_access',
    'access arguments'  => array('administer scald atoms'),
    'file'              => 'includes/scald.admin.inc',
    'type'              => MENU_LOCAL_TASK,
  );
  $items['admin/structure/scald'] = array(
    'title'             => 'Scald',
    'description'       => 'Manage Scald Atom Types, Contexts, and their associated settings.',
    'page callback'     => 'scald_admin_dashboard',
    'access callback'   => 'user_access',
    'access arguments'  => array('administer scald'),
    'file'              => 'includes/scald.admin.inc',
    'type'              => MENU_NORMAL_ITEM,
  );
  $items['admin/structure/scald/%scald_type'] = array(
    'title'             => 'Type',
    'title callback'    => 'scald_type_name',
    'title arguments'   => array(3),
    'weight'            => -80,
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('scald_admin_type_form', 3),
    'access callback'   => 'user_access',
    'access arguments'  => array('administer scald'),
    'file'              => 'includes/scald.admin.inc',
    'type'              => MENU_NORMAL_ITEM,
  );
  $items['admin/structure/scald/%scald_type/edit'] = array(
    'title'             => 'Edit',
    'type'              => MENU_DEFAULT_LOCAL_TASK,
    'weight'            => -20,
  );
  $items['admin/structure/scald/%scald_type/contexts'] = array(
    'title'             => 'Contexts',
    'weight'            => 40,
    'page callback'     => 'scald_admin_contexts',
    'page arguments'    => array(3),
    'access callback'   => 'user_access',
    'access arguments'  => array('administer scald'),
    'file'              => 'includes/scald.admin.inc',
    'type'              => MENU_LOCAL_TASK,
  );
  $items['admin/config/content/scald'] = array(
    'title'             => 'Scald',
    'weight'            => 20,
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('scald_settings_form'),
    'access callback'   => 'user_access',
    'access arguments'  => array('administer scald'),
    'file'              => 'includes/scald.admin.inc',
  );
  $items['atoms/add'] = array(
    'title' => 'Create Atom',
    'page callback' => 'scald_atom_add',
    'access callback' => 'scald_atom_add_access',
    'file' => 'includes/scald.pages.inc'
  );
  // The following two items do the same thing. We can consider them aliases.
  $items['atoms/add/%scald_type'] = array(
    'title' => 'Create Atom',
    'page callback' => 'scald_atom_add_page',
    'page arguments' => array(FALSE, 2),
    'access callback' => 'scald_atom_add_access',
    'access arguments' => array(2),
    'file' => 'includes/scald.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['atoms/%ctools_js/add/%scald_type'] = array(
    'title' => 'Create Atom',
    'page callback' => 'scald_atom_add_page',
    'page arguments' => array(1, 3),
    'access callback' => 'scald_atom_add_access',
    'access arguments' => array(3),
    'file' => 'includes/scald.pages.inc',
    'type' => MENU_CALLBACK,
  );

  $items['atoms/view/%scald_atom'] = array(
    'title' => 'View Atom',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('scald_atom_view', 2),
    'access callback' => 'scald_action_permitted',
    'access arguments' => array(2, 'view'),
    'file' => 'includes/scald.pages.inc'
  );
  $items['atoms/edit/%scald_atom'] = array(
    'title' => 'Edit Atom',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('scald_atom_edit', 2),
    'access callback' => 'scald_action_permitted',
    'access arguments' => array(2, 'edit'),
    'file' => 'includes/scald.pages.inc'
  );

  return $items;
} // end scald_menu()

/**
 * Scald Atom entity uri callback.
 */
function scald_atom_uri($atom) {
  return array(
    'path' => 'atoms/view/' . $atom->sid
  );
}

/**
 * Load callback for the %scald_type placeholder.
 */
function scald_type_load($type) {
  $types = scald_types();
  if (isset($types[$type])) {
    return $types[$type];
  }
  return FALSE;
}

/**
 * Title callback for the atom type administration page.
 */
function scald_type_name($type) {
  return $type->title;
}

/**
 * Access callback for the atom add page.
 */
function scald_atom_add_access($type = NULL) {
  if (user_access('administer scald atoms') || user_access('create atom of any type')) {
    return TRUE;
  }

  // If we got a type, check that the user can create atom of this type.
  if (!empty($type)) {
    return user_access('create atom of ' . $type->type . ' type');
  }

  // Otherwise, iterate over our atom types to check if there's one that the
  // current user is allowed to create.
  $types = scald_types();
  foreach ($types as $type) {
    if (user_access('create atom of ' . $type->type . ' type')) {
      return TRUE;
    }
  }
  return FALSE;
}



/**
 * Implementation of hook_theme()
 */
function scald_theme($existing, $type, $theme, $path) {
  return array(
    'scald_render_error' => array(
      'arguments' => array('type' => NULL, 'message' => NULL)
    )
  );
}


/**
 * Implementation of hook_filter().
 */
function scald_filter($op, $delta = 0, $format = -1, $text = '', $cache_id = 0) {
  switch ($op) {
    case 'list':
      return array(0 => t('Scald Atom Shorthand Filter'));
      break;

    case 'no cache':
      // Caching is disabled to ensure that current renderings of Atoms are
      //  returned.  Invalidating specific {cache_filter} entries is nearly
      //  impossible due to a hash of the text-to-filter being used as a key.
      //  Because Scald caches Atom renderings, the performance hit should be
      //  relatively insignficant.
      return TRUE;
      break;

    case 'description':
      return t('Allows users to include Scald Atom Shorthand (SAS) in a textarea and have the Atoms rendered in a particular Scald Context.  Often combined with WYSIWYG editors and custom textarea parsing to automatically generate the SAS.');
      break;

    case 'prepare':
      return $text;
      break;

    case 'process':
      $override = variable_get('scald_filter_sas_' . $format . '_override', FALSE);
      $context = variable_get('scald_filter_sas_' . $format . '_context', FALSE);
      return scald_sas_to_rendered($text, $context, $override);
      break;

    case 'settings':
      $context_options = array();
      $contexts = scald_contexts();
      foreach ($contexts as $name => $context) {
        $context_options[$name] = $context['title'];
      }

      $form['filter_sas'] = array(
        '#type'        => 'fieldset',
        '#title'       => t('Scald Atom Shorthand Filter'),
        '#collapsible' => TRUE,
        '#collapsed'   => FALSE,
      );
      $form['filter_sas']['scald_filter_sas_' . $format . '_context'] = array(
        '#type'          => 'select',
        '#title'         => t('Scald Context'),
        '#description'   => t('Choose a Scald Context to use for rendering Scald Atoms included in the text using Scald Atom Shorthand.'),
        '#default_value' => variable_get('scald_filter_sas_' . $format . '_context', 'title'),
        '#options'       => $context_options,
      );
      $form['filter_sas']['scald_filter_sas_' . $format . '_override'] = array(
        '#type'          => 'checkbox',
        '#title'         => t('Override specified Context'),
        '#description'   => t('If checked, the Scald Context specified above will be used even if there is a Context is specified the Scald Atom Shorthand.'),
        '#default_value' => variable_get('scald_filter_sas_' . $format . '_override', FALSE),
      );
      return $form;
      break;

    default:
      return $text;
      break;
  }
} // end scald_filter()



/**
 * Implementation of hook_filter_tips().
 */
function scald_filter_tips($delta, $format, $long = FALSE) {
  if ($long) {
    return t('Any instance of Scald Atom Shorthand (SAS) will be replaced with a rendered Scald Atom.  SAS can take any of the following formats: [scald=SID], [scald=SID:context], or [scald=SID:context context-options].  SID is the Scald ID, context is a context-slug, and context-options are additional formatting clues to give to the Context.');
  }
  return t('You may include Scald Atom Shorthand such as [scald=12].  NOTE: WYSIWYG or rich-text editors often handle Scald Atom Shorthand automatically and manually including it is not necessary if such an editor is in use.');
} // end scald_filter_tips()



/**
 * Implementation of hook_views_api()
 */
function scald_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'scald') .'/includes/',
  );
}

/**
 * Implementation of hook_flush_caches()
 */
function scald_flush_caches() {
  return array('cache_scald');
}

function theme_scald_render_error($context, $message){
	return '<h3>' . $message . '</h3>';
}







/**
 * Compute actions bitsting for a single role
 * return the result and store them to cache
 */
function scald_compute_role_actions($role) {
  // Get permissions for the specified role
  $permissions = user_role_permissions($role);

  // Get all Scald actions
  $scald_actions = scald_actions();

  // Get rid
  $rid = key($role);

  // Prepare empty bit strings
  $role_actions = array(
    'own' => 0,
    'any' => 0,
  );

  // Get enabled permissions for this role
  $role_permissions = $permissions[$rid];

  // Foreach action
  foreach($scald_actions as $key => $action) {
    // Foreach permission
    foreach($role_permissions as $perm => $enabled) {
      if(!strcmp($perm, $key . ' own atom')) {
        $role_actions['own'] |= $action['bitmask'];
      }
      else if(!strcmp($perm, $key . ' any atom')) {
        $role_actions['any'] |= $action['bitmask'];
      }
    }
  }

  cache_set('scald_actions_bitstring_for_rid_' . $rid, $role_actions, 'cache_scald', CACHE_TEMPORARY);
  return $role_actions;
}




/**
 * Implementation of hook_form_FORM_ID_alter()
 * Hook into the permissions submit form to compute our bitstrings
 */
function scald_form_user_admin_permissions_alter(&$form, &$form_state, $form_id) {
  // Add our custom submit handler.
  $form['#submit'][] = 'scald_permissions_submit';
}
function scald_permissions_submit($form, &$form_state) {
  // Recompute actions bitstrings for all Drupal roles
  foreach(user_roles() as $rid => $role_name) {
    scald_compute_role_actions(array($rid => $role_name));
  }
}

/**
 * Build an array of action links for a given atom
 */
function scald_atom_user_build_actions_links($atom, $query = NULL) {
  $actions = scald_actions();
  $supported_actions = array('view', 'edit');
  $current_actions = scald_user_actions($atom);

  $links = array();
  foreach ($actions as $action => $details) {
    if(in_array($action, $supported_actions) && ($current_actions & $details['bitmask'])) {
      $links[$action] = array(
        'title' => $details['title'],
        'href' => 'atoms/' . $action . '/' . $atom->sid,
      );

      if($query) {
        $links[$action]['query'] = $query;
      }
    }
  }

  return $links;  
}

