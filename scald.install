<?php

/**
 * @file
 * Scald Installation
 *
 * The database schema is heavily commented; review for details.
 *
 * NOTE: For the registries which are essentially the makeup of the Scald
 *  Configuration Object, no indexes are specified because they are usually
 *  referenced only to retrieve all the data.  In fact, there should never be a
 *  situation in which a module is querying directly against those tables.
 *
 * @ingroup scald
 */

require_once('scald.constants.inc');



/**
 * Implementation of hook_schema().
 */
function scald_schema() {
  $schema = array();

  $schema['cache_scald'] = drupal_get_schema_unprocessed('system', 'cache');

  // Scald Atom Registry
  $schema['scald_atoms'] = array(
    'description' => t('The Scald Atom registry.'),
    'fields'      => array(
      'sid'       => array(
        'description' => t('The Scald Identifier, a unique integer ID for a given Scald Atom.'),
        'type'        => 'serial',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'not null'    => TRUE,
      ),
      'provider'  => array(
        'description' => t('The name of the module which provides this Atom.  The Provider module should implement the Scald Provider API for Atoms.  FK {system}.name'),
        'type'        => 'varchar',
        'length'      => 255,
        'not null'    => TRUE,
        'default'     => 'scald',
      ),
      'type'      => array(
        'description' => t('The Scald Unified Type slug for this Atom\'s type.  FK {scald_types}.type'),
        'type'        => 'varchar',
        'length'      => SCALD_SLUG_MAX_LENGTH,
        'not null'    => TRUE,
        'default'     => 'composite',
      ),
      'base_id'   => array(
        'description' => t('The identifier used by the Scald Atom Provider that registered Atom to determine additional properties (e.g. a Drupal NID or a YouTube ID).  FK'),
        'type'        => 'varchar',
        'length'      => 255,
        'not null'    => FALSE,
        'default'     => NULL,
      ),
      'publisher' => array(
        'description' => t('The Drupal User ID of the user who *registered* this Atom.  Makes no implications about the Authorship.  FK {users}.uid'),
        'type'        => 'int',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'not null'    => TRUE,
        'default'     => 0,
      ),
      'actions'   => array(
        'description' => t('The Scald Actions bitstring for this Atom.'),
        'type'        => 'int',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'not null'    => TRUE,
        'default'     => 0,
      ),
      'title'     => array(
        'description' => t('The title of this Scald Atom.'),
        'type'        => 'varchar',
        'length'      => 255,
        'not null'    => TRUE,
        'default'     => '',
      ),
    ),
    'primary key' => array('sid'),
    'unique keys' => array(
      'u_provider_type_base_id' => array(array('provider', 64), array('type', 64), array('base_id', 64)),
    ),
    'indexes'     => array(
      'i_sid_provider_base_id'  => array('sid', array('provider', 64), array('base_id', 64)),
      'i_sid_actions'           => array('sid', 'actions'),
      'i_type_sid'              => array('type', 'sid'),
      'i_publisher_sid'         => array('publisher', 'sid'),
      'i_base_id'               => array(array('base_id', 64)),
    ),
  );

  // Scald Author Registry
  $schema['scald_authors'] = array(
    'description' => t('The Scald Author registry.'),
    'fields'      => array(
      'aid'  => array(
        'description' => t('The Author ID.'),
        'type'        => 'serial',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'not null'    => TRUE,
      ),
      'name' => array(
        'description' => t('The name of the Author -- no first & last, just a single string.'),
        'type'        => 'varchar',
        'length'      => 255,
        'not null'    => TRUE,
        'default'     => '',
      ),
      'uid'  => array(
        'description' => t('The Drupal User ID of the Author, *if* they are a user of the site.  A null value implies the author is not a Drupal user.  FK {users}.uid'),
        'type'        => 'int',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'default'     => NULL,
      ),
      'url'  => array(
        'description' => t('A URL at which the Author can be reached.  Preferred to an email address for privacy.'),
        'type'        => 'varchar',
        'length'      => 255,
        'default'     => NULL,
      ),
    ),
    'primary key' => array('aid'),
    'indexes'     => array(
      'i_aid_uid'      => array('aid', 'uid'),
      'i_uid_aid'      => array('uid', 'aid'),
      'i_aid_name_url' => array('aid', array('name', 64), array('url', 64)),
    ),
  );

  $schema['scald_atom_authors'] = array(
    'description' => t('Mapping between Scald Atoms and the Authors of those Atoms.'),
    'fields'      => array(
      'sid'     => array(
        'description' => t('The Atom ID.  FK {scald_atoms}.sid'),
        'type'        => 'int',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'not null'    => TRUE,
        'default'     => 0,
      ),
      'aid'     => array(
        'description' => t('The Author ID of an author of the Atom.  FK {scald_authors}.aid'),
        'type'        => 'int',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'not null'    => TRUE,
        'default'     => 0,
      ),
      'weight'  => array(
        'description' => t('Used for determining the order of the Authors for an Atom.'),
        'type'        => 'int',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'default'     => NULL,
      ),
    ),
    'primary key' => array('sid', 'aid'),
    'unique keys' => array(
      'k_sid_weight' => array('sid', 'weight'),
    ),
  );

  // Scald Unified Type Registry
  $schema['scald_types'] = array(
    'description' => t('The Scald Unified Type registry.'),
    'fields'      => array(
      'type'         => array(
        'description' => t('The Scald Unified Type slug, used to uniquely identify the Type'),
        'type'        => 'varchar',
        'length'      => SCALD_SLUG_MAX_LENGTH,
        'not null'    => TRUE,
        'default'     => 'composite',
      ),
      'provider'         => array(
        'description' => t('The name of the module which provides this Type.  The Provider module should implement the Scald Provider API for Types.  FK {system}.name'),
        'type'        => 'varchar',
        'length'      => 255,
        'not null'    => TRUE,
        'default'     => 'scald',
      ),
      'title'       => array(
        'description' => t('The human-readable title of this Type.  Publicly Viewable'),
        'type'        => 'varchar',
        'length'      => 255,
        'not null'    => TRUE,
        'default'     => t('Scald Composite'),
      ),
      'description' => array(
        'description' => t('A description of the Type for the benefit of Admins and Devs.'),
        'type'        => 'text',
        'size'        => 'medium',
      ),
    ),
    'primary key' => array('type'),
  );

  $schema['scald_context_type_transcoder'] = array(
    'description' => t('A mapping between Types, Contexts, file formats, and Transcoders'),
    'fields'      => array(
      'context'    => array(
        'description' => t('The Scald Context slug for a Scald Context.  Fk {scald_contexts}.context'),
        'type'        => 'varchar',
        'length'      => SCALD_SLUG_MAX_LENGTH,
        'not null'    => TRUE,
        'default'     => 'title',
      ),
      'type'       => array(
        'description' => t('The Scald Unified Type slug for a Scald Unified Type.  FK {scald_types}.type'),
        'type'        => 'varchar',
        'length'      => SCALD_SLUG_MAX_LENGTH,
        'not null'    => TRUE,
        'default'     => 'composite',
      ),
      'file_format'     => array(
        'description' => t('A file format slug.  Could be just about anything, but this is supposed to coincide with the format specifiers used by Scald Transcoders.'),
        'type'        => 'varchar',
        'length'      => SCALD_SLUG_MAX_LENGTH,
        'not null'    => TRUE,
        'default'     => 'passthrough',
      ),
      'transcoder' => array(
        'description' => t('The Scald Transcoder slug for a Scald Transcoder.  FK {scald_transcoders}.transcoder'),
        'type'        => 'varchar',
        'length'      => SCALD_SLUG_MAX_LENGTH,
        'not null'    => TRUE,
        'default'     => 'passthrough',
      ),
    ),
    'primary key' => array('type', 'context'),
  );

  $schema['scald_role_actions'] = array(
    'description' => t('The mapping of various Actions to Drupal user roles.'),
    'fields'      => array(
      'rid'     => array(
        'description' => t('A Drupal user role ID.  FK {role}.rid'),
        'type'        => 'int',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'not null'    => TRUE,
        'default'     => 0,
      ),
      'actions' => array(
        'description' => t('The Scald Action bitstring for this role.'),
        'type'        => 'int',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'not null'    => TRUE,
        'default'     => 0,
      ),
    ),
    'primary key' => array('rid'),
  );

  $schema['scald_licenses'] = array(
    'description' => t('Definitions of Licenses as sets of permitted Scald Actions'),
    'fields'      => array(
      'lid'         => array(
        'description' => t('The License ID; an arbitrarily defined identifier for the license.'),
        'type'        => 'serial',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'not null'    => TRUE,
      ),
      'title'       => array(
        'description' => t('The human-readable name of this License (often presented as an alternative for users).'),
        'type'        => 'varchar',
        'length'      => 255,
        'not null'    => TRUE,
        'default'     => t('Scald License Default Title'),
      ),
      'description' => array(
        'description' => t('A description of a given License for public consumption.'),
        'type'        => 'text',
        'size'        => 'medium',
      ),
      'actions'     => array(
        'description' => t('The Scald Action bitstring for this License.'),
        'type'        => 'int',
        'size'        => 'big',
        'unsigned'    => TRUE,
        'not null'    => TRUE,
        'default'     => 0,
      ),
    ),
    'primary key' => array('lid'),
  );

  return $schema;
}



/**
 * Implementation of hook_install().
 *
 * Installs the schema and then ensure that the hooks implemented by Scald Core
 *  will fire before those implemented by any Scald Providers (a direct
 *  modification of the {system} table is the only way to accomplish this).
 */
function scald_install() {
  // Get Scald hooks to run earlier than other modules
  db_query("UPDATE {system} SET weight = -50 WHERE name = 'scald'");
}



/**
 * Implementation of hook_uninstall().
 *
 * Removes the database tables and persistant variables managed through Drupal.
 *  Anything set in the Scald Admin Interface will be forgotten.
 *
 * Uninstall the DB schema and clean up as much as is feasible.
 */
function scald_uninstall() {
  variable_del('scald_config');
  variable_del('scald_providers');
  variable_del('scald_atom_defaults');
  variable_del('scald_context_fallbacks');
  variable_del('scald_actions_publisher');
}



/**
 * Implementation of hook_enable().
 *
 * Ensures that various configuration options are set so that Scald Core can
 *  make certain assumptions about the contents of variables.
 */
function scald_enable() {
  variable_set('scald_context_fallbacks', array('@default' => array('title')));

  // Register all existing Users as Scald Authors
  // Determine wether we can run it straight, or need to switch to batch processing,
  // depending on the number of users account that need to be registered.
  $count = db_query("SELECT COUNT(uid) FROM {users} WHERE uid > 0")->fetchField();
  if ($count < SCALD_ENABLE_BATCH_LIMIT) {
    $context = array();
    scald_enable_batch($context);
  }
  else {
    batch_set(array(
      'title'             => t('Registering all Users as potential Scald Authors'),
      'operations'        => array(
        array('scald_enable_batch', array()),
      ),
      'progress_message'  => '',  // No message because the batch function provides its own
      'file'              => drupal_get_path('module', 'scald') . '/scald.install',
    ));
    batch_process('admin/build/modules');
  }
}



/**
 * Implementation of hook_disable().
 *
 * Settings configured in the Scald Admin Interface should remain.  Lower-levl
 *  configurations, however, are removed as they will need to be rebuilt if the
 *  Scald Core is re-enabled later.
 */
function scald_disable() {
}



/**
 * Batch addition of all Users as Scald Authors.
 */
function scald_enable_batch(&$context) {
  if (!isset($context['sandbox']['last_uid'])) {
    $context['sandbox']['progress']   = 0;
    $context['sandbox']['last_uid']   = 0;
    $context['sandbox']['total']      = db_query("
      SELECT
        COUNT(uid)
      FROM
        {users}
      WHERE
        uid > 0
      ORDER BY
        uid
    ")->fetchField();
  }

  $users_results = db_select('users', 'u')
    ->fields('u', array('uid', 'name'))
    ->condition('u.uid', 0, '>')
    ->orderBy('u.uid')
    ->range($context['sandbox']['progress'], SCALD_ENABLE_BATCH_LIMIT)
    ->execute();
  while ($user_raw = $users_results->fetchAssoc()) {
    scald_register_author($user_raw);
    $context['sandbox']['last_uid'] = $user_raw['uid'];
    $context['sandbox']['progress']++;
  }

  $context['message']   = t('Updated @current of @total users.', array('@current' => $context['sandbox']['progress'], '@total' => $context['sandbox']['total']));
  $context['finished']  = $context['sandbox']['progress'] / $context['sandbox']['total'];
}

/**
 * Updates the schema from the 6.x version
 */
function scald_update_7000() {
  // TODO: Find what's needed here.
  // Drop the table that were just storing the results of info hooks
  db_drop_table('scald_actions');
  db_drop_table('scald_atom_providers');
  db_drop_table('scald_contexts');
  db_drop_table('scald_contexts_type_formats');
  db_drop_table('scald_relationships');
  db_drop_table('scald_transcoders');
  db_drop_table('scald_transcoder_formats');

  // Drop the relationships support from Scald Core.
  // Better solutions for this problems exists in Contrib, now
  // that we're going for an entity-based solutions
  db_drop_table('scald_atom_relationships');
  
  // Convert the 'scald_atom_types' variable, whose format changed
  // between 6.x and 7.x
  $defaults = variable_get('scald_atom_defaults', NULL);
  if (!empty($defaults)) {
    $temp = array();
    $properties = array('thumbnail_source', 'description', 'actions');
    foreach ($properties as $property) {
      foreach ($defaults->{$property} as $name => $value) {
        $temp[$name][$property] = $source;
      }
    }
    $new_defaults = array();
    foreach ($temp as $name => $default) {
      $new_defaults[$name] = (object)$default;
    }
    variable_set('scald_atom_defaults', $new_defaults);
  }
}
