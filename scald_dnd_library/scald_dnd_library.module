<?php
/* $Id$ */

/**
 * @file
 * Scald DnD Library 
 */

// CONSTANTS
define('SCALD_DND_LIBRARY_PAGE_SIZE', 5);

/**
 * Implementation of hook_menu().
 */
function scald_dnd_library_menu() {
  return array(
    'sdl-library/library' => array(
      'page callback' => 'scald_dnd_library_library',
      'access arguments' => array('access scald dnd library'),
      'type' => MENU_CALLBACK
    ),
    'sdl-library/autocomplete-tags' => array(
      'page callback' => 'scald_dnd_library_autocomplete_tags',
      'access arguments' => array('access scald dnd library'),
      'type' => MENU_CALLBACK
    ),
  );
}

/**
 * Implementation of hook_perm().
 */
function scald_dnd_library_perm() {
  return array('access scald dnd library');
}

/**
 * Implements hook_theme().
 */
function scald_dnd_library_theme() {
  return array(
    'sdl_header' => array('arguments' => array('page' => NULL, 'count' => 0, 'form' => NULL), 'template' => 'sdl-header'),
    'sdl_library' => array('arguments' => array('page' => NULL, 'library_items' => NULL), 'template' => 'sdl-library'),
    'sdl_footer' => array('arguments' => array('page' => NULL, 'count' => 0, 'pager' => NULL), 'template' => 'sdl-footer'),
    'sdl_library_item' => array('arguments' => array('informations' => array(), 'image' => NULL)),
    'sdl_editor_item' => array('arguments' => array('informations' => array(), 'image' => NULL)),
    'sdl_editor_legend' => array('arguments' => array('atom' => array())),
    'sdl_preview_item' => array('arguments' => array('atom' => array(), 'image' => NULL))
  );
}

/**
 * Implements hook_dnd_libraries_info.
 */
function scald_dnd_library_dnd_libraries_info() {
  $return = array();
  if (module_exists('views')) {
    $return['scald/library_dnd'] = t('Scald Library');
  }
  $return['sdl-library/library'] = t('Scald Library (Basic)');
  return $return;
}

/**
 * Return a JSON representation of a Library Page.
 */
function scald_dnd_library_library() {
  // Parse querystring
  $search_query_title = ($_GET['filter-title']) ? $_GET['filter-title'] : NULL;
  $search_query_tags = ($_GET['tags']) ? explode(",", $_GET['tags']) : NULL;
  
  $types = ($_GET['type']) ? $_GET['type'] : array(
    'audio' => 'audio',
    'image' => 'image'
  );
  
  $page = ($_GET['page']) ? $_GET['page'] : 1;

  $library = array(
    'library' => '',
    'editor_representations' => array(),
    'library_previews' => array(),
  );

  $library_items = array();
  
  
  $config = variable_get('scald_config', array());
  $providers = array();
  foreach ($types as $type) {
    foreach($config->types[$type]['atom_providers'] as $provider) {
      $providers[] = $provider;
    }
  }
  $provider_placeholders = db_placeholders($providers, 'text');
  $type_placeholders = db_placeholders($types, 'text');
  
  // Init empty node id listing which will be filled
  // if some tags gives some node/resource
  $nids_found_from_tags = array();
  
  // Searching with tags
  if ($search_query_tags) {
    foreach ($search_query_tags as $key => $value) {
      $search_query_tags[$key] = trim($value);
    }
    $vids = array();
    // Finds matching tags vocabularies for content types
    $result = db_query("SELECT DISTINCT(v.vid) AS vid FROM {vocabulary} v INNER JOIN {vocabulary_node_types} vnt ON v.vid = vnt.vid WHERE v.tags = 1 AND vnt.type IN($provider_placeholders) ORDER BY v.weight", $providers);

    while ($vid = db_result($result)) {
      $vids[] = $vid;
    }

    // Try to map user typed tags into term tid from this vocabularies
    $tags_placeholders = db_placeholders($search_query_tags, 'text');
    $vids_placeholders = db_placeholders($vids, 'int');
    // Build arguments for query
    $arguments = array_merge($search_query_tags, $vids);

    $result = db_query("SELECT t.tid FROM {term_data} t WHERE LOWER(t.name) IN($tags_placeholders) AND t.vid IN($vids_placeholders)", $arguments);

    while ($tid = db_result($result)) {
      $tids[] = $tid;
    }
    if (count($tids) > 0) {
      // Select nodes belonging to those tids
      $tids_placeholders = db_placeholders($tids, 'int');
      $clause = '';
      
      foreach ($tids as $index => $tid) {
       $joins .= " INNER JOIN {term_node} tn". $index ." ON n.vid = tn". $index .".vid";
       $wheres .= " AND tn". $index .".tid IN ($tid)";
     }

      // Merges arguments
      $arguments = $providers;

      $result = pager_query("SELECT DISTINCT(n.nid)
                          FROM {node} n
                          $joins
                          AND n.type IN($provider_placeholders)
                          $wheres
                          ORDER BY n.created DESC",
                          SCALD_DND_LIBRARY_PAGE_SIZE, NULL, NULL,  $arguments);

      while ($nid = db_result($result)) {
        $nids_found_from_tags[] = $nid;
      }
    }
  } // END - Searching with tags

  $args = array($search_query_title) + $types;
  
  if (count($nids_found_from_tags) > 0 && $search_query_tags) {
    $nids_placeholders = db_placeholders($nids_found_from_tags, 'int');
    $args = array_merge($args, $nids_found_from_tags);
    $result = pager_query("SELECT s.sid FROM {scald_atoms} s LEFT JOIN {content_field_ressource_date_creation} dc ON s.base_id=dc.nid WHERE s.title LIKE '%%%s%%' AND type IN($type_placeholders) AND base_id IN($nids_placeholders) AND actions > 1 ORDER BY dc.field_ressource_date_creation_value DESC", SCALD_DND_LIBRARY_PAGE_SIZE, 0, NULL, $args);
  }
  elseif (count($nids_found_from_tags) == 0 && $search_query_tags) {
    unset($result);
  }
  elseif (!$search_query_tags) {
    $result = pager_query("SELECT s.sid FROM {scald_atoms} s LEFT JOIN {content_field_ressource_date_creation} dc ON s.base_id=dc.nid WHERE s.title LIKE '%%%s%%' AND type IN($type_placeholders) AND actions > 1 ORDER BY dc.field_ressource_date_creation_value DESC", SCALD_DND_LIBRARY_PAGE_SIZE, 0, NULL, $args);
  }
  // Get back the total number of element that pager_query fetched.
  global $pager_total_items;
  $count = $pager_total_items[0];
  $pager = theme('pager');

  // Run search & build array
  while($sid = db_result($result)) {
    $atom = scald_fetch($sid);
    scald_prerender($atom, 'sdl_editor_representation');
    $library['editor_representations'][$sid] = array(
      'body'  => scald_render($atom, 'sdl_editor_representation'),
      'title' => $atom->title,
      'meta'  => array(
        'action' => $atom->base_entity->license->action_fin,
        'legend' => theme('sdl_editor_legend', $atom)
      )
    );
    $library['library_previews']['sdl-'. $sid] = scald_render($sid, 'sdl_preview');
    $library_items[$sid] = scald_render($sid, 'sdl_library_item');
  }
  $library['library'] = 
    theme('sdl_header', $page, $count, drupal_get_form('scald_dnd_library_form', $types))
    . theme('sdl_library', $page, $library_items)
    . theme('sdl_footer', $page, $count, $pager);

  // Use standard Drupal pager variables
  // &page=X
  // Assemble array
  return drupal_json($library);
}

function scald_dnd_library_form($form_state, $currentTypes) {
  $form = array();
  $form['filter-title'] = array(
    '#type'  => 'textfield',
    '#title' => t('Title'),
    '#default_value' => $_GET['filter-title']
  );
  $form['tags'] = array(
    '#type'  => 'textfield',
    '#autocomplete_path' => 'sdl-library/autocomplete-tags', 
    '#title' => t('Tags'),
    '#default_value' => $_GET['tags']
  );
  $options = array();
  $types = _scald_types();
  foreach($types as $name => $type) {
    $options[$name] = $type['title'];
  }
  $form['type'] = array(
    '#type' => 'checkboxes',
    '#options' => $options,
    '#title' => t('Type'),
    '#default_value' => $currentTypes
  );
  $form['filter-submit'] = array(
    '#type'  => 'submit',
    '#value' => t('Filter')
  );
  $form['#method'] = 'GET';
  return $form;
}

function template_preprocess_sdl_header(&$variables) {}
function template_preprocess_sdl_library(&$variables) {
  if (is_object($variables['view'])) {
    $variables['library_items'] = array();
    $results = $variables['view']->result;
    foreach ($results as $result) {
      $sid = $result->sid;
      $variables['library_items'][$sid] = scald_render($sid, 'sdl_library_item');
    }
  }
  else {
    $variables['library_items'] = $variables['options'];
  }
#dpm('$variables');
#dpm($variables, '$variables');
}
function template_preprocess_sdl_footer(&$variables) {
  //$start = $variables['page'] * SCALD_DND_LIBRARY_PAGE_SIZE
}

function scald_dnd_library_scald_provider() {
  return array(
  'contexts' => array(
    'sdl_editor_representation' => array(
      'title' => t('Editor Representation'),
      'description' => t('The Editor Rep'),
      'render_language' => 'XHTML',
      'parseable'       => TRUE,
      'formats'    => array(
        'image' => array('jpeg', 'png', 'passthrough'),
        'audio' => array('wav', 'ogg', 'mp3', 'passthrough'),
      ),
    ),
    'sdl_preview' => array(
      'title' => t('Preview Representation'),
      'description' => t('The Preview Rep'),
      'render_language' => 'XHTML',
      'parseable'       => FALSE,
      'formats'    => array(
        'image' => array('jpeg', 'png', 'passthrough'),
        'audio' => array('wav', 'ogg', 'mp3', 'passthrough'),
      ),
    ),
    'sdl_library_item' => array(
      'title' => t('Library item'),
      'description' => t('The Library Rep'),
      'render_language' => 'XHTML',
      'parseable'       => FALSE,
      'formats'    => array(
        'image' => array('jpeg', 'png', 'passthrough'),
        'audio' => array('wav', 'ogg', 'mp3', 'passthrough'),
      ),
    )
  )
  );
}

function scald_dnd_library_scald_render($atom, $context, $options = array()) {
  if ($atom->rendered->file_transcoded_url) {
    $path = $atom->rendered->file_transcoded_url;
  }
  else {
    $path = $atom->rendered->thumbnail_source_url;
  }
  $attributes = array();
  if ($context == 'sdl_library_item') {
    $path .= (strpos($path, '?') !== FALSE)? '&' : '?';
    $path .= 'dnd_id='. $atom->sid;
    $attributes += array('class' => 'drop', 'width' => '48', 'draggable' => 'TRUE');
  }
  elseif ($context == 'sdl_preview') {
    $path .= (strpos($path, '?') !== FALSE)? '&' : '?';
    $path .= 'dnd_id='. $atom->sid;
    $attributes += array('class' => 'drop');
  }
  else {
    $attributes += array('class' => 'dnd-dropped');
  }
  // Try to get the image size.
  if ($atom->rendered->file_transcoded_url && $atom->file_transcoded) {
    list($width, $height, $type, $attr) = @getimagesize($atom->file_transcoded);
  }
  elseif ($atom->thumbnail_source) {
    list($width, $height, $type, $attr) = @getimagesize($atom->thumbnail_source);
  }
  if ($width && $height) {
    $attributes += array(
      'width' => $width,
      'height' => $height
    );
  }
  $image = "<img src='$path' alt='' ". drupal_attributes($attributes) . ' />';
  switch ($context) {
    case 'sdl_preview':
      $render = theme('sdl_preview_item', $atom, $image);
      break;
    case 'sdl_library_item':
      $render = theme('sdl_library_item', $atom, $image);
      break;
    default:
      $render = theme('sdl_editor_item', $atom->rendered, $image);
  }
  return "
<!-- scald={$atom->sid}:{$context} -->
  {$render}
<!-- END scald={$atom->sid} -->
";
}

function theme_sdl_library_item($atom, $image) {
  $informations = $atom->rendered;
  if (is_object($atom->base_entity) && is_numeric($atom->base_entity->nid)) {
    $view = l(t('View'), 'node/'. $atom->base_entity->nid, array('attributes' => array('target' => '_blank')));
    $edit = l(t('Edit'), 'node/'. $atom->base_entity->nid .'/edit', array('attributes' => array('target' => '_blank')));
    $links = "$view / $edit";
  }
  $return =  "
  <div class='image'>
    {$image}
  </div>";
  if ($informations->player) {
    $return .= "
  <div class='player'>
    {$informations->player}
  </div>";
  }
  $return .= "
  <div class='meta'>
    <div class='title'>{$informations->title}</div>
    <div class='date'>{$informations->type}</div>
    <div class='author'>{$informations->authors[0]['link']}</div>
    <div class='links'>{$links}</div>
  </div>
  <br class='clear' />
  ";
  return $return;
}

function theme_sdl_editor_item($informations, $image) {
  $data = $informations->player ? $informations->player : $image;
  return "
  <div class='image'>
    {$data}
  </div>
  ";
}

function theme_sdl_editor_legend($atom) {
  $informations = $atom->rendered;
  $by = isset($informations->authors[0]['link']) ? $informations->author[0]['link'] : $informations->publisher['link'];
  return "
  <div class='meta'>
    {$informations->title}, par {$by}
  </div>
  ";
}

function theme_sdl_preview_item($atom, $image) {
  $ressource = theme('sdl_editor_item', $atom->rendered, $image);
  $node = node_load($atom->base_id);
  if (is_numeric($node->license->limite)) {
    $node->license->limite .= ' jours';
  }
  $tags = array();
  if (is_array($node->tags)) {
    foreach($node->tags as $voc) {
      foreach($voc as $term) {
        $tags[] = $term->name;
      }
    }
  }
  if (count($tags)) {
    $tags = implode(', ', $tags);
  }
  else {
    $tags = t('None');
  }
  if ($node->license->depublication) {
    $date = format_date(strtotime($node->license->depublication));
    $depublication = "
      <dt>Utilisable jusqu'à</dt>
      <dd>{$date}</dd>
    ";
  }
  else {
    $depublication = '';
  }
  return "
<div class='sdl-preview-item'>
  <h3>Ressource</h3>
    $ressource
  <h3>Informations</h3>
  <dl>
    <dt>Copyright</dt>
    <dd>{$node->license->copyright}</dt>
    <dt>Utilisable pendant</dt>
    <dd>{$node->license->limite}</dd>
    <dt>Tags</dt>
    <dd>{$tags}</dd>
    $depublication
  </dl>
</div>
  ";
}

function scald_dnd_library_autocomplete_tags($string = '') {
  // Vocabularies' IDs are 28, 29 and 30
  $vids = array(28, 29, 30);

  $vids_placeholders = db_placeholders($vids, 'int');

  $array = drupal_explode_tags($string);

  // Fetch last tag
  $last_string = trim(array_pop($array));
  $matches = array();
  if ($last_string != '') {
    $args = array_merge($vids, array($last_string));
    $result = db_query_range("SELECT t.tid, t.name FROM {term_data} t WHERE t.vid IN($vids_placeholders) AND LOWER(t.name) LIKE LOWER('%%%s%%')", $args, 0, 10);

    $prefix = count($array) ? implode(', ', $array) .', ' : '';

    while ($tag = db_fetch_object($result)) {
      $n = $tag->name;
      // Commas and quotes in terms are special cases, so encode 'em.
      if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {
        $n = '"'. str_replace('"', '""', $tag->name) .'"';
      }
      $matches[$prefix . $n] = check_plain($tag->name);
    }
  }

  drupal_json($matches);
}

/**
 * Implements hook_form_alter().
 */
function scald_dnd_library_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'views_exposed_form') {
    // Check if the style plugin is scald_library.
    $view = $form['#parameters'][1]['view'];
    if ($view->display[$view->current_display]->display_options['style_plugin'] == 'scald_library') {
      // Put the filters in a fieldset... Hackish.
      $filter = t('Filter');
      drupal_add_js('misc/collapse.js');
      $form['#prefix'] = "<fieldset class='collapsible collapsed'><legend>$filter</legend>";
      $form['#suffix'] = "</fieldset>";
      // Try to expose a sort based on the fields defined for this display.
      // That's hackish too, but won't be needed when Views 3 hits a stable
      // release, so let's say it's a temporary workaround.
      $fields = $view->field;
      $options = array();
      foreach ($fields as $name => $field) {
        if ($field->definition['click sortable']) {
          $options[$name] = $field->options['label'];
        }
      }
      if (count($options)) {
        $filter = t('Filter');
        $form['order'] = array(
          '#type' => 'select',
          '#title' => t('Sort'),
          '#options' => $options,
          '#default_value' => $_GET['order']
        );
        $form['sort'] = array(
          '#type' => 'select',
          '#title' => '',
          '#options' => array('desc' => t('Descending'), 'asc' => t('Ascending')),
          '#default_value' => $_GET['sort']
        );
        $form['submit']['#weight'] = 1;
        $form['reset'] = array(
          '#type' => 'markup',
          '#value' => "<input type='reset' value='". t('Reset') ."' />",
          '#weight' => 2
        );
      }
    }
  }
}

/**
 * Implements hook_views_api().
 */
function scald_dnd_library_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'scald_dnd_library') .'/includes',
  );
}
