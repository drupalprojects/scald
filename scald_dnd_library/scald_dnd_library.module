<?php

/**
 * @file
 * Scald DnD Library
 */

// CONSTANTS
define('SCALD_DND_LIBRARY_PAGE_SIZE', 5);

/**
 * Implementation of hook_menu().
 */
function scald_dnd_library_menu() {
  return array(
    'sdl-library/library' => array(
      'page callback' => 'scald_dnd_library_library',
      'access arguments' => array('access scald dnd library'),
      'type' => MENU_CALLBACK
    ),
  );
}

/**
 * Implementation of hook_perm().
 */
function scald_dnd_library_perm() {
  return array('access scald dnd library');
}

/**
 * Implements hook_theme().
 */
function scald_dnd_library_theme() {
  return array(
    'sdl_header' => array('arguments' => array('page' => NULL, 'count' => 0, 'form' => NULL), 'template' => 'sdl-header'),
    'sdl_library' => array('arguments' => array('page' => NULL, 'library_items' => NULL), 'template' => 'sdl-library'),
    'sdl_footer' => array('arguments' => array('page' => NULL, 'count' => 0, 'pager' => NULL), 'template' => 'sdl-footer'),
    'sdl_library_item' => array('arguments' => array('informations' => array(), 'image' => NULL)),
    'sdl_editor_item' => array('arguments' => array('informations' => array(), 'image' => NULL)),
    'sdl_editor_legend' => array('arguments' => array('atom' => array())),
    'sdl_preview_item' => array('arguments' => array('atom' => array(), 'image' => NULL))
  );
}

/**
 * Implements hook_dnd_libraries_info.
 */
function scald_dnd_library_dnd_libraries_info() {
  $return = array();
  if (module_exists('views')) {
    $return['scald/library_dnd'] = t('Scald Library');
  }
  $return['sdl-library/library'] = t('Scald Library (Basic)');
  return $return;
}

/**
 * Return a JSON representation of a Library Page.
 */
function scald_dnd_library_library() {
  // Parse querystring
  $search_query_title = ($_GET['filter-title']) ? $_GET['filter-title'] : NULL;

  $types = ($_GET['type']) ? $_GET['type'] : array(
    'image' => 'image',
    'video' => 'video'
  );

  $page = ($_GET['page']) ? $_GET['page'] : 1;

  $library = array(
    'library' => '',
    'editor_representations' => array(),
    'library_previews' => array(),
  );

  $library_items = array();
  $type_placeholders = db_placeholders($types, 'text');

  $args = array($search_query_title) + $types;

  $result = pager_query("SELECT s.sid FROM {scald_atoms} s WHERE s.title LIKE '%%%s%%' AND type IN($type_placeholders) AND actions > 1 ORDER BY s.sid DESC", SCALD_DND_LIBRARY_PAGE_SIZE, 0, NULL, $args);
  // Get back the total number of element that pager_query fetched.
  global $pager_total_items;
  $count = $pager_total_items[0];
  $pager = theme('pager');

  // Run search & build array
  while($sid = db_result($result)) {
    scald_dnd_library_add_item($library, $sid);
    $library_items[$sid] = scald_render($sid, 'sdl_library_item');
  }
  $library['library'] =
    theme('sdl_header', $page, $count, drupal_get_form('scald_dnd_library_form', $types))
    . theme('sdl_library', $page, $library_items)
    . theme('sdl_footer', $page, $count, $pager);

  // Use standard Drupal pager variables
  // &page=X
  // Assemble array
  return drupal_json($library);
}

/**
 * Adds an item in the library array.
 */
function scald_dnd_library_add_item(&$library, $sid) {
  $atom = scald_fetch($sid);
  $library['atoms'][$sid] = array(
    'meta' => array(
      'title' => $atom->title,
      'type' => $atom->type,
      'legend' => theme('sdl_editor_legend', $atom),
      'action' => $atom->base_entity->license->action_fin
    ),
    'editor' => scald_render($atom, 'sdl_editor_representation'),
    'preview' => scald_render($atom, 'sdl_preview'),
    'library' => scald_render($atom, 'sdl_library_item')
  );
}

function scald_dnd_library_form($form_state, $currentTypes) {
  $form = array();
  $form['filter-title'] = array(
    '#type'  => 'textfield',
    '#title' => t('Title'),
    '#default_value' => $_GET['filter-title']
  );
  $options = array();
  $types = _scald_types();
  foreach($types as $name => $type) {
    $options[$name] = $type['title'];
  }
  $form['type'] = array(
    '#type' => 'checkboxes',
    '#options' => $options,
    '#title' => t('Type'),
    '#default_value' => $currentTypes
  );
  $form['filter-submit'] = array(
    '#type'  => 'submit',
    '#value' => t('Filter')
  );
  $form['#method'] = 'GET';
  return $form;
}

/**
 * Implements hook_preprocess_sdl_library.
 */
function template_preprocess_sdl_library(&$variables) {
  if (is_object($variables['view'])) {
    $variables['library_items'] = array();
    $results = $variables['view']->result;
    foreach ($results as $result) {
      $sid = $result->sid;
      $variables['library_items'][$sid] = scald_render($sid, 'sdl_library_item');
    }
  }
  elseif (empty($variables['library_items']) && isset($variables['options'])) {
    $variables['library_items'] = $variables['options'];
  }
}

/**
 * Implements hook_scald_provider.
 */
function scald_dnd_library_scald_provider() {
  return array(
  'contexts' => array(
    'sdl_editor_representation' => array(
      'title' => t('Editor Representation'),
      'description' => t('The Editor Rep'),
      'render_language' => 'XHTML',
      'parseable'       => TRUE,
      'formats'    => array(
        'image' => array('jpeg', 'png', 'passthrough'),
        'audio' => array('wav', 'ogg', 'mp3', 'passthrough'),
      ),
    ),
    'sdl_preview' => array(
      'title' => t('Preview Representation'),
      'description' => t('The Preview Rep'),
      'render_language' => 'XHTML',
      'parseable'       => FALSE,
      'formats'    => array(
        'image' => array('jpeg', 'png', 'passthrough'),
        'audio' => array('wav', 'ogg', 'mp3', 'passthrough'),
      ),
    ),
    'sdl_library_item' => array(
      'title' => t('Library item'),
      'description' => t('The Library Rep'),
      'render_language' => 'XHTML',
      'parseable'       => FALSE,
      'formats'    => array(
        'image' => array('jpeg', 'png', 'passthrough'),
        'audio' => array('wav', 'ogg', 'mp3', 'passthrough'),
      ),
    )
  )
  );
}

/**
 * Implements hook_scald_render.
 */
function scald_dnd_library_scald_render($atom, $context, $options = array()) {
  if ($atom->rendered->file_transcoded_url) {
    $path = $atom->rendered->file_transcoded_url;
  }
  else {
    $path = $atom->rendered->thumbnail_source_url;
  }
  $attributes = array();
  if ($context == 'sdl_library_item') {
    $path .= (strpos($path, '?') !== FALSE)? '&' : '?';
    $path .= 'dnd_id='. $atom->sid;
    $attributes += array('class' => 'drop', 'draggable' => 'TRUE');
  }
  elseif ($context == 'sdl_preview') {
    $path .= (strpos($path, '?') !== FALSE)? '&' : '?';
    $path .= 'dnd_id='. $atom->sid;
    $attributes += array('class' => 'drop');
  }
  else {
    $attributes += array('class' => 'dnd-dropped');
  }
  // Try to get the image size.
  if ($atom->rendered->file_transcoded_url && $atom->file_transcoded) {
    list($width, $height, $type, $attr) = @getimagesize($atom->file_transcoded);
  }
  elseif ($atom->thumbnail_source) {
    list($width, $height, $type, $attr) = @getimagesize($atom->thumbnail_source);
  }
  if ($width && $height) {
    $attributes += array(
      'width' => $width,
      'height' => $height
    );
  }
  $image = "<img src='$path' alt='' ". drupal_attributes($attributes) . ' />';
  switch ($context) {
    case 'sdl_preview':
      $render = theme('sdl_preview_item', $atom, $image);
      break;
    case 'sdl_library_item':
      $render = theme('sdl_library_item', $atom, $image);
      break;
    default:
      $render = theme('sdl_editor_item', $atom->rendered, $image);
  }

  return $render;
}

/**
 * Returns HTML for an atom rendered in the "Library Item" context.
 */
function theme_sdl_library_item($atom, $image) {
  $informations = $atom->rendered;
  if (is_object($atom->base_entity) && is_numeric($atom->base_entity->nid)) {
    $view = l(t('View'), 'node/'. $atom->base_entity->nid, array('attributes' => array('target' => '_blank')));
    $edit = l(t('Edit'), 'node/'. $atom->base_entity->nid .'/edit', array('attributes' => array('target' => '_blank')));
    $links = "<div class='links'>$view / $edit</div>";
  }
  else {
    $links = '';

  }
  $return =  "
  <div class='image'>
    {$image}
  </div>";
  if (!empty($informations->player)) {
    $return .= "
  <div class='player'>
    {$informations->player}
  </div>";
  }
  $return .= "
  <div class='meta'>
    <div class='title'>{$informations->title}</div>
    <div class='type type-{$informations->type}'</div>
    <div class='author'>{$informations->authors[0]['link']}</div>
    {$links}
  </div>
  <span class='clear' />
  ";
  return $return;
}

/**
 * Returns HTML for an atom rendered in the "Editor Representation" context.
 */
function theme_sdl_editor_item($informations, $image) {
  $data = !empty($informations->player) ? $informations->player : $image;
  return "
  <div class='image'>
    {$data}
  </div>
  ";
}

/**
 * Returns HTML for the legend of an atom, used in the Editor Representation context.
 */
function theme_sdl_editor_legend($atom) {
  $informations = $atom->rendered;
  $by = isset($informations->authors[0]['link']) ? $informations->authors[0]['link'] : $informations->publisher['link'];
  $by = t('by %name', array('%name' => $by));
  return "
  <div class='meta'>
    <!--copyright={$sid}-->{$informations->title}, {$by}<!--END copyright={$sid}-->
  </div>
  ";
}

/**
 * Returns HTML for an atom rendered in the "Preview" context.
 */
function theme_sdl_preview_item($atom, $image) {
  $resource_label = t('Resource');
  $informations_label = t('Informations');
  $resource = theme('sdl_editor_item', $atom->rendered, $image);
  $title_label = t('Title');
  $title_value = $atom->rendered->title;
  $author_label = t('Author');
  $author_name = $atom->rendered->authors[0]['link'];
  return "
<div class='sdl-preview-item'>
  <h3>$resource_label</h3>
    $resource
  <h3>$informations_label</h3>
  <dl>
    <dt>$title_label</dt>
    <dd>$title_value</dd>
    <dt>$author_label</dt>
    <dd>$author_name</dt>
  </dl>
</div>
  ";
}

/**
 * Implements hook_form_alter().
 */
function scald_dnd_library_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'views_exposed_form') {
    // Check if the style plugin is scald_library.
    $view = $form['#parameters'][1]['view'];
    if ($view->display_handler->get_option('style_plugin') == 'scald_library') {
      // Put the filters in a fieldset... Hackish.
      $filter = t('Filter');
      drupal_add_js('misc/collapse.js');
      $form['#prefix'] = "<fieldset class='collapsible collapsed'><legend>$filter</legend>";
      $form['#suffix'] = "</fieldset>";
      // Try to expose a sort based on the fields defined for this display.
      // That's hackish too, but won't be needed when Views 3 hits a stable
      // release, so let's say it's a temporary workaround.
      $fields = $view->field;
      $options = array();
      foreach ($fields as $name => $field) {
        if ($field->definition['click sortable']) {
          $options[$name] = $field->options['label'];
        }
      }
      if (count($options)) {
        $filter = t('Filter');
        $form['order'] = array(
          '#type' => 'select',
          '#title' => t('Sort'),
          '#options' => $options,
          '#default_value' => $_GET['order']
        );
        $form['sort'] = array(
          '#type' => 'select',
          '#title' => '',
          '#options' => array('desc' => t('Descending'), 'asc' => t('Ascending')),
          '#default_value' => $_GET['sort']
        );
        $form['submit']['#weight'] = 1;
        $form['reset'] = array(
          '#type' => 'markup',
          '#value' => "<input type='reset' value='". t('Reset') ."' />",
          '#weight' => 2
        );
      }
    }
  }
}

/**
 * Implements hook_views_api().
 */
function scald_dnd_library_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'scald_dnd_library') .'/includes',
  );
}

/**
 * Provides default ImageCache presets that can be overridden by site
 * administrators.
 *
 * @return array
 *   An array of imagecache preset definitions. Each definition can be
 *   generated by exporting a preset from the database. Each preset
 *   definition should be keyed on its presetname (for easier interaction
 *   with drupal_alter) and have the following attributes:
 *     "presetname": the imagecache preset name. Required.
 *     "actions": an array of action defintions for this preset. Required.
 */
function scald_dnd_library_imagecache_default_presets() {
  $presets = array();
  $presets['Library'] = array (
    'presetname' => 'Library',
    'actions' => array (
      0 => array (
        'weight' => '0',
        'module' => 'imagecache',
        'action' => 'imagecache_scale',
        'data' => array (
          'width' => '48',
          'height' => '',
          'upscale' => 0,
        ),
      ),
    ),
  );
  return $presets;
}
